# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/swissevote.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literature programming approach used applying the R Markdown format.

.onUnload <- function (libpath) {
  
  pkgpins::deregister(pkg = pkg)
}

.onLoad <- function(libname, pkgname) {
  
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption("swissevote.global_cache_lifespan",
                                     default = "30 days"))
  
  # set local path to Google Drive folder dependent on username
  options(swissevote.path_raw_data = switch(EXPR = Sys.info()[["user"]],
                                            "salim" = "~/Arbeit/ZDA/Google Drive/edc-projekt/iVoting_dataset/Datenquellen/",
                                            NULL))
}

utils::globalVariables(names = c(".",
                                 "aaData",
                                 "Abstimmungs_Datum",
                                 "Abstimmungs_Text",
                                 "all_of",
                                 "ballot_votes_e_voting_electorate",
                                 "ballot_votes_total",
                                 "canton",
                                 "cantonal_elected_power",
                                 "cantonal_election_procedure",
                                 "combined_elected_power",
                                 "combined_election_procedure",
                                 "combined_level",
                                 "comments",
                                 "country",
                                 "district",
                                 "election_level",
                                 "ends_with",
                                 "e_votes",
                                 "e_voting_electorate",
                                 "federal_elected_power",
                                 "federal_election_procedure",
                                 "group",
                                 "InitialCode",
                                 "is_cantonal",
                                 "is_cross_vote_aggregated",
                                 "is_election",
                                 "is_election_date",
                                 "is_entire_group_in_all_votes",
                                 "is_federal",
                                 "is_matched_group",
                                 "is_municipal",
                                 "is_preregistration_required",
                                 "is_wassenaar_corrected",
                                 "level",
                                 "limited_to_cantons",
                                 "link",
                                 "matched_group_notes",
                                 "matches",
                                 "municipal_elected_power",
                                 "municipal_election_procedure",
                                 "municipality",
                                 "MutationDate",
                                 "MutationNumber",
                                 "Name_Politische_Ebene",
                                 "nr_of_cantonal_referendums",
                                 "nr_of_federal_referendums",
                                 "nr_of_municipal_referendums",
                                 "postal_votes_e_voting_electorate",
                                 "postal_votes_total",
                                 "proposal_nrs",
                                 "referendum_level",
                                 "starts_with",
                                 "subject",
                                 "subject_summary",
                                 "starts_with",
                                 "Termin",
                                 "TerminalCode",
                                 "Titel der Vorlage",
                                 "total_electorate",
                                 "type",
                                 "V1",
                                 "V2",
                                 "V3",
                                 "V5",
                                 "V6",
                                 "V7",
                                 "vote_count_e_voting_electorate",
                                 "vote_count_total"))

pkg <- utils::packageName()

regex_counterproposal_fr <- "(?i)(co?n?tre-?projet(?!\\s(direct|relatif))|question\\ssubsidiaire)"

e_voting_cantons <- tibble::tribble(
  
         ~canton, ~canton_short,
       "Argovia",          "AG",
    "Basel-City",          "BS",
          "Bern",          "BE",
      "Fribourg",          "FR",
        "Geneva",          "GE",
        "Glarus",          "GL",
       "Grisons",          "GR",
       "Lucerne",          "LU",
     "Neuchatel",          "NE",
  "Schaffhausen",          "SH",
     "Solothurn",          "SO",
    "St. Gallen",          "SG",
       "Thurgau",          "TG",
          "Vaud",          "VD",
        "Zurich",          "ZH"
  )

metadata_raw_geneva <- readr::read_csv(file = "metadata_raw_geneva.csv",
                                       col_types = "Dcllllicc")

path_raw_data <- function(...,
                          ext = "") {
  
  fs::path(getOption("swissevote.path_raw_data"), ...,
           ext = ext) %>%
    fs::path_real()
}

municipalities <- function(canton = c("Geneva", "Neuchatel", "Zurich")) {
  
  switch(EXPR = rlang::arg_match(canton),
         "Geneva" = c("Ani\u00e8res",
                      "Cologny",
                      "Carouge",
                      "Meyrin",
                      "Vandoeuvres",
                      "Collonge-Bellerive",
                      "Onex",
                      "Versoix",
                      "Bernex",
                      "Ch\u00eane-Bourg",
                      "Grand-Saconnex",
                      "Lancy",
                      "Th\u00f4nex",
                      "Vernier",
                      "Perly-Certoux",
                      "Plan-les-Ouates",
                      "Ch\u00eane-Bougeries",
                      "Avusy",
                      "Aire-la-Ville",
                      "Troinex",
                      "Avully",
                      "Bardonnex",
                      "Bellevue",
                      "Cartigny",
                      "C\u00e9ligny",
                      "Chancy",
                      "Choulex",
                      "Collex-Bossy",
                      "Confignon",
                      "Corsier",
                      "Dardagny",
                      "Gen\u00e8ve",
                      "Genthod",
                      "Gy",
                      "Hermance",
                      "Jussy",
                      "Laconnex",
                      "Meinier",
                      "Pregny-Chamb\u00e9sy",
                      "Presinge",
                      "Puplinge",
                      "Russin",
                      "Satigny",
                      "Soral",
                      "Veyrier"),
         rlang::abort("Not implemented yet."))
}

#' Determine combination of three-code variables (`combined_election_procedure`)
#'
#' @param ... Up to three individual codes as integers. `pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return An integer scalar.
determine_3_code_combo <- function(...) {
  
  input_codes <-
    rlang::list2(...) %>%
    purrr::flatten_dbl() %>%
    as.integer()
  
  combined_code <- NA_integer_
  
  # show warning if all three codes are NA
  if (all(is.na(input_codes))) {
    
    rlang::warn("`combined_code` couldn't be determined because all codes are `NA`!")
    
  } else {
    
    # define a vector of all codes excluding NAs
    all_codes <- input_codes[!is.na(input_codes)]
    
    # if all codes are the same, just assign the first one
    if (length(unique(all_codes)) == 1L) {
      
      combined_code <- all_codes[1L]
      
      # else combined code must be 3
    } else combined_code <- 3L
  }
  
  combined_code
}

#' Determine combination of seven-code variables (like `combined_level`)
#'
#' @param ... Up to three individual codes as integers. `pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return An integer scalar.
determine_7_code_combo <- function(...) {
  
  input_codes <-
    rlang::list2(...) %>%
    purrr::flatten_dbl() %>%
    as.integer()
  
  combined_code <- NA_integer_
  
  # show warning if all three codes are NA
  if (all(is.na(input_codes))) {
    
    rlang::warn("`combined_code` couldn't be determined because all codes are `NA`!")
    
  } else {
    
    # define a vector of all codes excluding NAs and 0s
    all_codes <- input_codes %>% magrittr::extract(!is.na(.) & !(. == 0L))
    
    # if `all_codes` is empty, return 0
    if (length(all_codes) == 0L) {
      
      combined_code <- 0L
      
      # if all codes are the same, just assign the first one
    } else if (length(unique(all_codes)) == 1L) {
      
      combined_code <- all_codes[1L]
      
      # handle remaining combinations
    } else {
      
      combined_code <- dplyr::case_when(7L %in% all_codes
                                        | all(all_codes > 3L)
                                        | all(c(1L, 6L) %in% all_codes)
                                        | all(c(2L, 5L) %in% all_codes)
                                        | all(c(3L, 4L) %in% all_codes)
                                        | all(c(1L, 2L, 3L) %in% all_codes)
                                        | all(c(1L, 4L, 5L) %in% all_codes) ~ 7L,
                                        all(all_codes %in% c(2L, 3L, 6L)) ~ 6L,
                                        all(all_codes %in% c(1L, 3L, 5L)) ~ 5L,
                                        all(all_codes %in% c(1L, 2L, 4L)) ~ 4L)
    }
  }
  
  combined_code
}

combine_elected_powers <- function(federal_elected_power = NA,
                                   cantonal_elected_power = NA,
                                   municipal_elected_power = NA) {
  
  combined_elected_power <-
    determine_7_code_combo(
      # convert federal_elected_power code to schema of cantonal/municipal_elected_power
      dplyr::if_else(federal_elected_power > 0L,
                     1L,
                     as.integer(federal_elected_power)),
      cantonal_elected_power,
      municipal_elected_power
    )
  
  combined_elected_power
}

combine_group <- function(...) {
  
  input_codes <-
    rlang::list2(...) %>%
    purrr::flatten_dbl() %>%
    as.integer()
  
  combined_code <- NA_integer_
  
  # show warning if all three codes are NA
  if (all(is.na(input_codes))) {
    
    rlang::warn("`combined_code` couldn't be determined because all codes are `NA`!")
    
  } else {
    
    # define a vector of all codes excluding NAs and 0s
    all_codes <- input_codes %>% magrittr::extract(!is.na(.) & !(. == 0L))
    
    # if `all_codes` is empty, return 0
    if (length(all_codes) == 0L) {
      
      combined_code <- 0L
      
      # if all codes are the same, just assign the first one
    } else if (length(unique(all_codes)) == 1L) {
      
      combined_code <- all_codes[1L]
      
      # handle remaining combinations
    } else {
      
      combined_code <- dplyr::case_when(6L %in% all_codes
                                        | all(c(2L, 5L) %in% all_codes)
                                        | all(c(3L, 4L) %in% all_codes)
                                        | all(c(4L, 5L) %in% all_codes)
                                        | all(c(1L, 2L, 3L) %in% all_codes) ~ 6L,
                                        all(all_codes %in% c(1L, 3L, 5L)) ~ 5L,
                                        all(all_codes %in% c(1L, 2L, 4L)) ~ 4L)
    }
    
    combined_code
  }
}

get_group_name <- function(group) {
  
  switch(EXPR = as.character(group),
         "1" = "Swiss citizens living in Switzerland" ,
         "2" = "Swiss citizens living abroad" ,
         "3" = "foreigners" ,
         "4" = "Swiss citizens living in Switzerland & Swiss citizens living abroad" ,
         "5" = "Swiss citizens living in Switzerland & foreigners" ,
         "6" = "Swiss citizens living in Switzerland & Swiss citizens living abroad & foreigners",
         NA_character_)
}

get_type_name <- function(type) {
  
  switch(EXPR = as.character(type),
         "1" = "referendum" ,
         "2" = "election" ,
         "3" = "both (referendum & election)",
         NA_character_)
}

get_level_name <- function(level) {
  
  switch(EXPR = as.character(level),
         "0" = "none",
         "1" = "federal only",
         "2" = "cantonal only",
         "3" = "municipal only",
         "4" = "federal & cantonal",
         "5" = "federal & municipal",
         "6" = "cantonal & municipal",
         "7" = "all three (federal & cantonal & municipal)",
         NA_character_)
}

get_federal_elected_power_name <- function(federal_elected_power) {
  
  switch(EXPR = as.character(federal_elected_power),
         "0" = "none",
         "1" = "legislature (National Council)" ,
         "2" = "legislature (Council of States)" ,
         "3" = "legislature (National Council & Council of States)",
         NA_character_)
}

get_elected_power_name <- function(elected_power) {
  
  switch(EXPR = as.character(elected_power),
         "0" = "none",
         "1" = "legislature",
         "2" = "executive",
         "3" = "judiciary",
         "4" = c("legislature", "executive"),
         "5" = c("legislature", "judiciary"),
         "6" = c("executive", "judiciary"),
         "7" = c("legislature", "executive", "judiciary"),
         NA_character_) %>%
    purrr::when(is.na(.) ~ .,
                ~ paste0(collapse = " & "))
}

get_election_procedure_name <- function(election_procedure) {
  
  switch(EXPR = as.character(election_procedure),
         "0" = "none",
         "1" = "proportional voting" ,
         "2" = "majority voting" ,
         "3" = "proportional voting & majority voting",
         NA_character_)
}

#' Convert between full canton names and their two-letter abbreviations
#'
#' @param cantons The full names or two-letter abbreviations of the cantons to be converted. A character vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' convert_canton_names(c("ZH", "VD", "AG"))
#' convert_canton_names(c("Zurich", "Vaud", "Argovia"))
#' convert_canton_names(c("ZH", "Vaud", "Argovia"))
convert_canton_names <- function(cantons) {
  
  converted_names <- character()
  
  for (canton_name in checkmate::assert_character(cantons,
                                                  any.missing = FALSE)) {
    
    long_match <- match(x = canton_name,
                        table = e_voting_cantons$canton)
    short_match <- match(x = canton_name,
                         table = e_voting_cantons$canton_short)
    
    if (!is.na(long_match)) {
      
      converted_names %<>% c(e_voting_cantons$canton_short[long_match])
      
    } else if (!is.na(short_match)) {
      
      converted_names %<>% c(e_voting_cantons$canton[short_match])
      
    } else rlang::abort(glue::glue("`{canton_name}` is not a valid e-voting canton."))
  }
  
  converted_names
}

read_raw_data <- function(canton = c("Bern", "Geneva", "Neuchatel"),
                          date,
                          specific_datasets = NULL) {
  
  data_raw <- switch(EXPR = rlang::arg_match(canton),
                     "Bern" = read_raw_data_bern(date = date),
                     "Geneva" = read_raw_data_geneva(date = date,
                                                     specific_datasets = specific_datasets),
                     "Neuchatel" = read_raw_data_neuchatel(date = date))
  
  data_raw
}

read_raw_data_bern <- function(date) {
  
  # assemble partial file path
  file_path <- path_raw_data(glue::glue("BE/BE_{date}"))
  
  # determine file type
  file_type <- dplyr::case_when(file.exists(paste0(file_path, ".csv")) ~ "csv",
                                file.exists(paste0(file_path, ".zip")) ~ "zip",
                                file.exists(paste0(file_path, ".xlsx")) ~ "xlsx",
                                TRUE ~ "NA")
  
  # complete file path
  file_path %<>% paste0(".", file_type)
  
  # read in data
  if (file_type == "xlsx") {
    
    data_raw <- readxl::read_excel(path = file_path,
                                   col_names = c("variable", "value"),
                                   col_types = c("text", "numeric"),
                                   skip = 0L)
    
  } else if (file_type != "NA") {
    
    data_raw <- readr::read_delim(file = file_path,
                                  col_names = c("variable", "value"),
                                  col_types = "cn",
                                  locale = locale(encoding = "UTF-8",
                                                  decimal_mark = "."),
                                  delim = ",",
                                  trim_ws = TRUE,
                                  skip = 0L)
  } else {
    
    # if file couldn't be found, print a warning and return an empty dataframe
    rlang::warn("File ", file_path, " neither found in XLSX nor in CSV or ZIP format!")
    
    data_raw <- tibble::tibble()
  }
  
  data_raw
}

read_raw_data_geneva <- function(date,
                                 check_municipalities = TRUE,
                                 remove_unknown_municipality_district_combos = remove_unknown_GE_municipality_district_combos,
                                 remove_NA_locality_codes = remove_GE_NA_locality_codes,
                                 remove_duplicated_votes = remove_duplicated_GE_votes,
                                 skip_problematic_dates = skip_problematic_GE_dates,
                                 specific_datasets = NULL) {
  
  # get filename(s) of Geneva dataset(s)
  filenames <-
    metadata_raw_geneva %>%
    dplyr::filter(date == !!date
                  & is_e_voting_available
                  & !is.na(filename)) %$%
    filename
  
  # take `specific_datasets` into account
  if (!is.null(specific_datasets)
      & length(filenames)) {
    
    constrained_dates <-
      specific_datasets %>%
      magrittr::extract2("Geneva") %>%
      unlist(recursive = FALSE) %>%
      names()
    
    if (date %in% constrained_dates) {
      
      specific_datasets %<>%
        magrittr::extract2("Geneva") %>%
        magrittr::extract2(date)
      
      filenames %<>% .[filenames %in% specific_datasets]
    }
  }
  
  # print a warning if some files are missing (filename = ?)
  if (metadata_raw_geneva %>%
      dplyr::filter(date == !!date
             & is_e_voting_available) %$%
      filename %>%
      is.na() %>%
      which() %>%
      length() %>%
      magrittr::is_greater_than(0L)) {
    
    rlang::warn(glue::glue("There are raw data files missing for Geneva @ {date}! Check `swissevote:::metadata_raw_geneva`."))
  }
  
  # read in table with codes and names of municipalities and districts
  municipality_district_codes_and_names <- readr::read_csv(file = path_raw_data("GE/GE_municipality_district_codes_and_names.csv"),
                                                           col_types = "iiicc",
                                                           trim_ws = TRUE,
                                                           skip = 0L)
  
  # create empty list
  data_raw_list <- list()
  
  # workaround: skip processing of problematic voting register datasets
  ## define the affected dates
  problematic_dates <- c("2004-09-26",
                         "2004-11-28",
                         "2005-04-24",
                         "2008-11-30")
  # NOTES: all the above 4 dates show the undocumented combo of
  #        `municipality_code_2_digits = 21` and `district_code = 99`
  #
  # TODO: get at the bottom of this!
  
  ## skip them all
  if (skip_problematic_dates &
      date %in% problematic_dates) {
    
    rlang::warn(glue::glue("Skipped processing data from {date} due to unresolved issues."))
    
  } else {
    
    # read in dataset file(s) and generate metadata
    # TODO: change metadata structure -> a 
    metadata <- tibble::tibble(file = character(),
                               incl_federal = logical(),
                               incl_cantonal = logical(),
                               incl_municipal = logical())
    
    for (filename in filenames) {
      
      metadata_raw_geneva_subset <-
        metadata_raw_geneva %>%
        dplyr::filter(date == !!date
                      & filename == !!filename) %T>%
        {checkmate::assert_true(x = nrow(.) == 1L,
                                .var.name = "nrow(metadata_raw_geneva_subset) == 1L")}
      
      data_raw <- read_raw_dataset_geneva(filename = filename,
                                          check_municipalities = check_municipalities,
                                          remove_unknown_municipality_district_combos = remove_unknown_municipality_district_combos,
                                          remove_NA_locality_codes = remove_NA_locality_codes,
                                          remove_duplicated_votes = remove_duplicated_votes,
                                          municipality_district_codes_and_names = municipality_district_codes_and_names)
      
      # skip empty dataframes (no raw data found)
      if (nrow(data_raw)) {
        
        data_raw_list[[filename]] <- data_raw
        
        metadata %<>% tibble::add_row(file = filename,
                                      incl_federal = metadata_raw_geneva_subset$is_federal,
                                      incl_cantonal = metadata_raw_geneva_subset$is_cantonal,
                                      incl_municipal = metadata_raw_geneva_subset$is_municipal)
      }
    }
    
    # append metadata to returned object
    data_raw_list %<>% c(list(metadata = metadata))
  }
  
  data_raw_list
}

read_raw_dataset_geneva <- function(filename,
                                    check_municipalities,
                                    remove_unknown_municipality_district_combos,
                                    remove_NA_locality_codes,
                                    remove_duplicated_votes,
                                    municipality_district_codes_and_names) {
  
  # assemble partial file path
  file_path <- path_raw_data("GE", filename)
  
  # determine file type
  ## prefer CSV > ZIP > XLSX
  file_type_precedence <- c("csv", "zip", "xlsx")
  
  file_type <-
    fs::path_dir(file_path) %>%
    fs::dir_ls(type = "file",
               glob = paste0(file_path, "*")) %>%
    fs::path_ext() %>%
    match(table = file_type_precedence) %>%
    sort() %>%
    dplyr::first() %>%
    {file_type_precedence[.]}
  
  # read in data
  ## if file couldn't be found, print a warning and return an empty tibble
  if (is.na(file_type)) {
    
    rlang::warn(glue::glue("File {file_path} neither found in XLSX nor in CSV or ZIP format!"))
    
    return(tibble::tibble())
    
  } else if (file_type == "xlsx") {
    
    data_raw <- readxl::read_excel(path = fs::path(file_path,
                                                   ext = file_type),
                                   col_types = "text",
                                   skip = 0L)
    
  } else {
    
    data_raw <-
      readr::read_file(file = fs::path(file_path,
                                       ext = file_type)) %>%
      # remove carriage return characters (otherwise data will be corrupted due to incorrect row splitting)
      stringr::str_remove_all(pattern = "\\r") %>%
      readr::read_delim(delim = ";",
                        trim_ws = TRUE,
                        # handle all columns as type character (in order to avoid information loss due to strange values)
                        col_types = readr::cols(.default = readr::col_character()),
                        skip = 0L)
  }
  
  # rename columns and convert locality code vars to type integer
  data_raw %<>%
    dplyr::rename(vote_channel = typvot,
                  sex = sexe,
                  marital_status = cec,
                  year_of_birth = dnaisaa,
                  municipality_code_2_digits = votcom,
                  country_canton_code = cnat,
                  year = annee,
                  vote_date = date,
                  is_eligible_federal = qualfed,
                  is_eligible_cantonal = qualcan,
                  is_eligible_municipal = qualcom,
                  district_code = votarr) %>%
    dplyr::mutate(dplyr::across(c(country_canton_code,
                                  municipality_code_2_digits,
                                  district_code),
                                as.integer))
  
  if ("agerevolu" %in% colnames(data_raw)) {
    
    data_raw %<>% dplyr::rename(age = agerevolu)
  }
  
  if ("datvot" %in% colnames(data_raw)) {
    
    data_raw %<>% dplyr::rename(date = datvot)
  }
  
  # remove duplicate votes (where `votcorr == "A"`; only if the necessary variable exists)
  if ("votcorr" %in% colnames(data_raw) & remove_duplicated_votes) {
    
    data_raw %<>% dplyr::filter(is.na(votcorr))
  }
  
  # add binary variable `has_voted`
  data_raw %<>% dplyr::mutate(has_voted = dplyr::case_when(is.na(vote_date) ~ NA,
                                                           !(as.integer(vote_date) %in% c(19000101L, 0L)) ~ TRUE,
                                                           TRUE ~ FALSE))
  
  # add binary variable `is_swiss_living_abroad`
  ## check if there are entries with no `municipality_code_2_digits` (`NA`)
  ### get number of affected entries
  nr_of_NA_municipality_code_2_digits <-
    is.na(data_raw$municipality_code_2_digits) %>%
    which() %>%
    length()
  
  if (nr_of_NA_municipality_code_2_digits > 0L) {
    ### print an informative warning
    warning(
      style_warn(paste0("\n", nr_of_NA_municipality_code_2_digits, " of a total of ", nrow(data_raw),
                        " entries in the raw Geneva data file ", style_var_value(filename), " have no ",
                        style_var_name("municipality_code_2_digits"), " set (", style_arg_invalid("NA"), ")!",
                        dplyr::if_else(condition = remove_NA_locality_codes,
                                true = " They have been removed.\n",
                                false = "\n"))),
      call. = FALSE,
      immediate. = TRUE
    )
    
    if (remove_NA_locality_codes) {
      
      ### remove affected entries
      data_raw %<>% dplyr::filter(!is.na(municipality_code_2_digits))
    }
  }
  ## generate `is_swiss_living_abroad`
  ## NOTICE: code 46 only available in dates >= 2015-06-14
  data_raw$is_swiss_living_abroad <- data_raw$municipality_code_2_digits == 46L
  
  # add binary variable `is_foreigner`
  ## check if there are entries with no `country_canton_code` (`NA`)
  ### get number of affected entries
  nr_of_NA_country_canton_code <-
    is.na(data_raw$country_canton_code) %>%
    which() %>%
    length()
  
  if (nr_of_NA_country_canton_code > 0L) {
    
    ### print an informative warning
    warning(
      style_warn(paste0("\n", nr_of_NA_country_canton_code, " of a total of ", nrow(data_raw),
                        " entries in the raw Geneva data file ", style_var_value(filename), " have no ",
                        style_var_name("country_canton_code"), " set (", style_arg_invalid("NA"), ")!",
                        dplyr::if_else(condition = remove_NA_locality_codes,
                                true = " They have been removed.\n",
                                false = "\n"))),
      call. = FALSE,
      immediate. = TRUE
    )
    
    if (remove_NA_locality_codes) {
      
      ### remove affected entries
      data_raw %<>% dplyr::filter(!is.na(country_canton_code))
    }
  }
  ## generate `is_foreigner`
  data_raw$is_foreigner <- !data_raw$is_swiss_living_abroad & data_raw$country_canton_code > 99L
  
  # add `municipality` and `district`
  ## fix "wrong" district codes in raw data (`01` instead of `00` as documented in the codebook)
  ### get all indices of municipalities with only one district code (excl. Swiss abroad)
  affected_indices <-
    data_raw %>%
    dplyr::filter(municipality_code_2_digits != 46L) %>%
    dplyr::select(municipality_code_2_digits, district_code) %>%
    unique() %>%
    dplyr::filter(district_code != 0L) %>%
    dplyr::group_by(municipality_code_2_digits) %>%
    dplyr::summarise(n = n(),
              .groups = "drop") %>%
    dplyr::filter(n == 1L) %$%
    municipality_code_2_digits %>%
    is_in(data_raw$municipality_code_2_digits, .) %>%
    which()
  
  ### get the district codes of the affected entries
  affected_district_codes <- unique(data_raw$district_code[affected_indices])
  
  ### replace `1` with `0` and print a warning about it
  if (length(affected_indices) > 0L) {
    
    warning(style_warn("\nThere were " %+% paste(length(affected_indices)) %+%
                         " entries in the raw Geneva data file " %+% filename %+%
                         " that had a \"wrong\" district code set. They have been fixed.\n" %+%
                         "The wrong district codes included the following numbers: " %+%
                         paste0(style_var_value(affected_district_codes),
                                collapse = ", ") %+% "\n"),
            call. = FALSE,
            immediate. = TRUE)
    
    data_raw$district_code[affected_indices] <- 0L
  }
  ## add municipality and district names
  data_raw %<>%
    dplyr::left_join(y = municipality_district_codes_and_names,
                     by = c("municipality_code_2_digits", "district_code")) %>%
    dplyr::select(-void_since)
  
  # check if `municipality` could be determined for all entries excl. Swiss living abroad
  if ( check_municipalities )
  {
    ## determine entries missing a municipality (mostly with the undocumented district code `99`)
    unknown_municipality_district_combos <-
      data_raw %>%
      dplyr::filter(!is_swiss_living_abroad
             & is.na(municipality))
    
    if ( nrow(unknown_municipality_district_combos) > 0L )
    {
      ## save missing municipalities to global environment
      assign(
        x =
          paste0("unknown_municipality_district_combos_GE_", filename),
        value =
          data_raw %>%
          dplyr::filter(!is_swiss_living_abroad
                 & is.na(municipality)),
        pos =
          globalenv()
      )
      
      ## print a warning with some hints
      warning(
        style_warn(
          "\nFor " %+% as.character(nrow(unknown_municipality_district_combos)) %+% " of a total of " %+%
            as.character(nrow(data_raw)) %+% " entries in the raw Geneva data file ", style_var_value(filename) %+%
            " no matching municipality could be found! This can either be due to flaws/errors in the data or because " %+%
            style_var_value("GE_municipality_district_codes_and_names.csv") %+% " needs an update." %+%
            dplyr::if_else(condition = remove_unknown_municipality_district_combos,
                           true = " The affected entries have been removed. To inspect them",
                           false = " To inspect the affected entries") %+% ", enter: " %+%
            style_prompt("View(unknown_municipality_district_combos_GE_", filename, ")") %+%
            "\n\nThe affected entries show the following combinations of " %+% style_var_name("municipality_code_2_digits") %+%
            " and " %+% style_var_name("district_code") %+% ":\n\n    " %+%
            # determine affected combinations of `municipality_code_2_digits` and `district_code`
            {
              unknown_municipality_district_combos %>%
                dplyr::select(municipality_code_2_digits, district_code) %>%
                dplyr::arrange(municipality_code_2_digits, district_code) %>%
                unique() %>%
                capture.output() %>%
                magrittr::extract(-1L) %>%
                paste(collapse = "\n    ")
            } %+% "\n"
        ),
        call. = FALSE,
        immediate. = TRUE
      )
      
      ## remove unknown municipalities
      if (remove_unknown_municipality_district_combos) {
        
        data_raw %<>% dplyr::anti_join(y = unknown_municipality_district_combos,
                                       by = colnames(data_raw))
      }
    }
  }
  
  data_raw
}

read_raw_data_neuchatel <- function(date) {
  
  # define column names and types depending on date
  if (lubridate::year(date) < 2016) {
    
    variable_names <- c("municipality",
                        "age",
                        "date",
                        "sex",
                        "vote_channel",
                        "vote_date",
                        "nr_of_voters",
                        "nr_of_votes",
                        "is_swiss_living_abroad",
                        "nationality_code",
                        "nationality")
    
    variable_types <- c("text",
                        "numeric",
                        "date",
                        "text",
                        "text",
                        "date",
                        "numeric",
                        "numeric",
                        "logical",
                        "numeric",
                        "text")
    
    variable_types_csv <- "cicccciilic"
    
  } else  {
    
    variable_names <- c("age",
                        "municipality",
                        "date",
                        "sex",
                        "vote_channel",
                        "vote_date",
                        "nr_of_voters",
                        "nr_of_votes",
                        "is_swiss_living_abroad",
                        "nationality_code",
                        "nationality")
    
    variable_types <- c("numeric",
                        "text",
                        "date",
                        "text",
                        "text",
                        "date",
                        "numeric",
                        "numeric",
                        "logical",
                        "numeric",
                        "text")
    
    variable_types_csv <- "iccccciilic"
  }
  
  # assemble partial file path
  file_path <- path_raw_data(glue::glue("NE/NE_{date}"))
  
  # determine file type
  file_type <- dplyr::case_when(file.exists(paste0(file_path, ".csv")) ~ "csv",
                                file.exists(paste0(file_path, ".zip")) ~ "zip",
                                file.exists(paste0(file_path, ".xlsx")) ~ "xlsx",
                                TRUE ~ "NA")
  
  # complete file path
  file_path %<>% paste0(".", file_type)
  
  # read in data
  if (file_type == "xlsx") {
    
    data_raw <- readxl::read_excel(path = file_path,
                                   col_names = variable_names,
                                   col_types = variable_types,
                                   skip = 1L)
    
  } else if ( file_type != "NA" )
  {
    data_raw <- readr::read_csv(file = file_path,
                                col_names = variable_names,
                                col_types = variable_types_csv,
                                trim_ws = TRUE,
                                skip = 1L)
  } else
  {
    # if file couldn't be found, print a warning and return an empty dataframe
    warning(style_warn("\nFile " %+% style_var_value(file_path) %+% " neither found in XLSX nor in CSV or ZIP format!\n"),
            call. = FALSE,
            immediate. = TRUE)
    
    return(tibble::tibble())
  }
  
  # delete obsolete NA columns
  data_raw <- data_raw[, 1:11]
  
  # ensure header line isn't mistakenly included (happens when file contains surplus rows at the beginning)
  if ( data_raw %>%
       as.matrix() %>%
       .[!is.na(.)] %>%
       stringr::str_detect(pattern = "(?i)(ele (libellÃ©|sexe|)|car mode votation)") %>%
       any() )
  {
    stop(style_error("\nThe NE data file " %+% style_var_value(file_path) %+% " seems to contain empty surplus rows at the beginning!\n" %+%
                       "Please remove them and try again."),
         call. = FALSE)
  }
  
  # add binary variable `is_foreigner`
  data_raw$is_foreigner <-
    dplyr::case_when(is.na(data_raw$nationality) ~ NA,
                     data_raw$nationality == "Suisse" ~ FALSE,
                     TRUE ~ TRUE)
  
  # check for missing nationalities
  if ( any(is.na(data_raw$is_foreigner)) )
  {
    warning(style_warn(paste0("\nFound ", style_var_value(is.na(data_raw$is_foreigner) %>% which() %>% length()),
                              " entries in raw data lacking a nationality (", style_arg_invalid("NA"),
                              ")! Please double-check raw data from ", style_var_value(date), ".")),
            call. = FALSE,
            immediate. = TRUE)
  }
  
  # check for invalid data
  if ( data_raw %>%
       dplyr::filter(is_foreigner & is_swiss_living_abroad) %>%
       nrow() %>%
       magrittr::is_greater_than(0L) )
  {
    stop(style_error("\nFound Swiss abroad data entry in raw data with nationality other than " %+% style_var_value("Suisse") %+%
                       "! Please double-check data."),
         call. = FALSE)
  }
  
  return(data_raw)
}

vote_dates_latest_neuchatel <- function() {
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               level = character(),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  raw_extract <-
    xml2::read_html(x = "https://www2.ne.ch/vote",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "table") %>%
    magrittr::extract2(4L) %>%
    rvest::html_nodes(css = "td")
  
  level_i <- NA
  
  for (i in seq_along(raw_extract)) {
    
    if (isTRUE(rvest::html_attr(x = raw_extract[[i]],
                                name = "class") == "VotationType")) {
      
      level_i <- switch(EXPR = rvest::html_text(x = raw_extract[[i]]),
                        "Scrutins f\u00e9d\u00e9raux" = "federal",
                        "Scrutins cantonaux" = "cantonal",
                        "Scrutins communaux" = "municipal")
      
    } else if (isTRUE(raw_extract[[i]] %>%
                      rvest::html_nodes(css = "a") %>%
                      rvest::html_attr(name = "class") %>%
                      magrittr::equals("SubSectionTitle"))
               & !is.na(level_i)) {
      
      text_i <-
        raw_extract[[i]] %>%
        rvest::html_text() %>%
        stringr::str_squish() %>%
        stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                             replacement = "\\1 \\4\\2") %>%
        stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                           simplify = FALSE) %>%
        purrr::flatten_chr()
      
      vote_dates %<>% tibble::add_row(date = lubridate::dmy(text_i[2L]),
                                      level = level_i,
                                      municipality = dplyr::if_else(condition = level == "municipal",
                                                                    true =
                                                                      text_i[1L] %>%
                                                                      stringr::str_extract(pattern = "^.+?(?= - )") %>%
                                                                      stringr::str_replace_all(pattern = "Les Geneveys s/Coffrane",
                                                                                               replacement = "Les Geneveys-sur-Coffrane"),
                                                                    false = NA_character_),
                                      is_election = stringr::str_detect(string = text_i[1L],
                                                                        pattern = "(?i) - (e|\u00e9)lection"),
                                      subject = dplyr::if_else(condition = level == "municipal",
                                                               true = stringr::str_extract(string = text_i[1L],
                                                                                           pattern = "(?<= - ).*$"),
                                                               false = text_i[1L]))
    }
  }
  
  vote_dates %>% dplyr::arrange(date, level, is_election)
}

#' Get federal vote dates
#'
#' @param source Federal vote dates can either be retrieved from the official website of the canton of _Neuchatel_ (default) or _Zurich_. Note that only
#'   referendum dates will be returned from `source = "Zurich"`, election dates can only be scraped from `source = "Neuchatel"`. On the other hand,
#'   `source = "Zurich"` will return referendum dates back to the 19th century, while `source = "Neuchatel"` only goes back to the turn of the millennium.
#' @param exclude_counterproposals Exclude indirect counterproposals and tie-breaker questions. A logical scalar.
#' @param use_cache `pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `pkgsnip::param_label("cache_lifespan")`
#'
#' @return `pkgsnippets::return_label("data")`
#' @export
vote_dates_federal <- function(source = c("Neuchatel", "Zurich"),
                               exclude_counterproposals = TRUE,
                               use_cache = TRUE,
                               cache_lifespan = "1 day") {
  
  pkgpins::with_cache(
    .fn = function(source,
                   exclude_counterproposals) {
      
      result <- switch(EXPR = source,
                       "Neuchatel" =
                         vote_dates_federal_neuchatel(exclude_counterproposals = exclude_counterproposals),
                       "Zurich" =
                         get_zurich_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                         dplyr::filter(level == "federal") %>%
                         dplyr::select(date, subject) %>%
                         dplyr::transmute(date,
                                          is_election = FALSE,
                                          limited_to_cantons = NA,
                                          subject))
      
      # incorporate GE Council of States vote dates
      result %>%
        dplyr::bind_rows(get_geneva_election_dates() %>%
                           dplyr::filter(level == "federal"
                                         & !(date %in% result$date)
                                         & date > min(result$date)) %>%
                           dplyr::transmute(date,
                                            is_election = TRUE,
                                            limited_to_cantons = "Geneva",
                                            subject = subject_summary)) %>%
        dplyr::arrange(date, is_election)
    },
    source = rlang::arg_match(source),
    exclude_counterproposals = exclude_counterproposals,
    .use_cache = use_cache,
    .cache_lifespan = cache_lifespan,
    .pkg = pkg
  )
}

vote_dates_federal_neuchatel <- function(exclude_counterproposals = FALSE) {
  
  # get archived vote dates
  vote_dates <-
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsFederaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(date = lubridate::dmy(date),
                     is_election = stringr::str_detect(string = subject,
                                                       pattern = "(?i)^(e|\u00e9)lection"),
                     limited_to_cantons = NA,
                     subject = subject)
  
  # incorporate latest vote dates (separate page)
  vote_dates %<>% dplyr::bind_rows(vote_dates_latest_neuchatel() %>%
                                     dplyr::filter(level == "federal") %>%
                                     dplyr::transmute(date,
                                                      is_election,
                                                      limited_to_cantons = NA,
                                                      subject))
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    vote_dates %<>%
      dplyr::filter(!(!is_election
                      & stringr::str_detect(string = subject,
                                            pattern = regex_counterproposal_fr))) %>%
      # manually exclude remaining cases
      dplyr::filter(!(date == "2002-09-22"
                     & subject == "L'or \u00e0 l'AVS, aux cantons et \u00e0 la Fondation\""))
  }
  
  # incorporate Council of States election dates
  vote_dates %>%
    dplyr::filter(is_election) %>%
    dplyr::bind_rows(get_neuchatel_cantonal_vote_dates(council_of_states = TRUE) %>%
                       dplyr::transmute(date,
                                        is_election,
                                        limited_to_cantons = dplyr::if_else(condition = date %in% vote_dates$date,
                                                                            true = NA_character_,
                                                                            false = "Neuchatel"),
                                        subject)) %>%
    dplyr::group_by(date, is_election, limited_to_cantons) %>%
    dplyr::summarise(subject = paste0(subject,
                                      collapse = "; "),
                     .groups = "drop") %>%
    dplyr::bind_rows(vote_dates %>% dplyr::filter(!is_election)) %>%
    dplyr::arrange(date, is_election)
}

#' Get cantonal vote dates
#'
#' @param cantons The names of the cantons to retrieve vote dates for. A character vector.
#' @inheritParams vote_dates_federal
#'
#' @inherit vote_dates_federal return
#' @export
vote_dates_cantonal <- function(cantons = c("Geneva", "Neuchatel", "Zurich"),
                                exclude_counterproposals = TRUE,
                                use_cache = TRUE,
                                cache_lifespan = "1 day") {
  
  pkgpins::with_cache(
    .fn = function(cantons,
                   exclude_counterproposals) {
      
      vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                                   canton = character(),
                                   is_election = logical(),
                                   subject = character())
      
      for (canton in cantons) {
        
        # print warning ...
        switch(
          EXPR = canton,
          # ... about missing ZH election dates
          "Zurich" = rlang::warn("For the Canton of ", canton,
                                 " only referendum dates can be scraped. The cantonal election dates have to be gathered by hand.")
        )
        
        if (canton %in% c("Neuchatel", "Zurich")) {
          
          vote_dates <-
            switch(EXPR = canton,
                   "Geneva" =
                     get_geneva_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::filter(level == "cantonal") %>%
                     dplyr::transmute(date,
                                      subject,
                                      is_election = FALSE) %>%
                     dplyr::bind_rows(get_geneva_election_dates() %>%
                                        dplyr::filter(level == "cantonal") %>%
                                        dplyr::transmute(date,
                                                         subject = subject_summary,
                                                         is_election = TRUE)) %>%
                     dplyr::mutate(canton = "Geneva"),
                   "Neuchatel" =
                     get_neuchatel_cantonal_vote_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::mutate(canton = "Neuchatel"),
                   "Zurich" =
                     get_zurich_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::filter(level == "cantonal") %>%
                     dplyr::mutate(canton = "Zurich",
                                   is_election = FALSE) %>%
                     dplyr::select(date, canton, is_election, subject),
                   tibble::tibble(date = lubridate::as_date(integer()),
                                  canton = character(),
                                  is_election = logical(),
                                  subject = character())) %>%
            dplyr::transmute(date, canton, is_election, subject) %>%
            dplyr::full_join(y = vote_dates,
                             by = colnames(vote_dates))
        } else {
          rlang::warn("Scraping vote dates from the canton of ", canton, " hasn't been implemented yet!")
        }
      }
      
      vote_dates %>% dplyr::arrange(date, canton, is_election)
    },
    cantons = cantons,
    exclude_counterproposals = exclude_counterproposals,
    .use_cache = use_cache,
    .cache_lifespan = cache_lifespan,
    .pkg = pkg
  )
}

#' Get municipal vote dates
#'
#' @inheritParams vote_dates_cantonal
#' @inheritParams vote_dates_federal
#'
#' @inherit vote_dates_federal return
#' @export
vote_dates_municipal <- function(cantons = c("Geneva", "Neuchatel", "Zurich"),
                                 exclude_counterproposals = TRUE,
                                 use_cache = TRUE,
                                 cache_lifespan = 86400L) {
  
  supported_cantons <- c("Geneva", "Neuchatel", "Zurich")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               canton = character(),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (canton in cantons) {
    
    cached_filepath <- paste0("backup/municipal_vote_dates_", convert_canton_names(canton), ".csv")
    
    # if `cached = TRUE` and last download was less than `cache_lifespan` seconds ago, read in cached data, otherwise download it from web
    if ((!use_cache |
         !file.exists(cached_filepath) |
         file.size(cached_filepath) == 0 |
         ((file.mtime(cached_filepath) + lubridate::dseconds(x = cache_lifespan)) < lubridate::now()))
        & canton %in% supported_cantons) {
      
      current_vote_dates <-
        switch(EXPR = canton,
               
               "Geneva" =
                 get_geneva_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                 dplyr::filter(level == "municipal") %>%
                 dplyr::transmute(date,
                                  municipality,
                                  is_election = FALSE,
                                  subject) %>%
                 dplyr::bind_rows(get_geneva_municipal_election_dates() %>%
                                    dplyr::transmute(date,
                                                     municipality,
                                                     is_election = TRUE,
                                                     subject)) %>%
                 dplyr::mutate(canton = "Geneva"),
               
               "Neuchatel" =
                 get_neuchatel_municipal_vote_dates(exclude_counterproposals = exclude_counterproposals) %>%
                 dplyr::mutate(canton = "Neuchatel"),
               
               "Zurich" =
                 get_zurich_municipal_vote_dates(exclude_counterproposals = exclude_counterproposals) %>%
                 dplyr::mutate(canton = "Zurich")) %>%
        dplyr::transmute(date, canton, municipality, is_election, subject)
      
      readr::write_csv(x = current_vote_dates,
                       path = cached_filepath)
      
      vote_dates %<>% dplyr::full_join(y = current_vote_dates,
                                       by = colnames(.))
      
    } else if (canton %in% supported_cantons) {
      
      vote_dates %<>% dplyr::full_join(y = readr::read_csv(file = cached_filepath,
                                                           col_types = "Dcclc"),
                                       by = colnames(.))
    } else {
      
      # print warning about unsupported cantons
      rlang::warn("Scraping vote dates from the Canton of ", canton, " hasn't been implemented yet!")
    }
  }
  
  vote_dates %>% dplyr::arrange(date, canton, municipality, is_election)
}

get_neuchatel_cantonal_vote_dates <- function(council_of_states = FALSE,
                                              exclude_counterproposals = FALSE) {
  # get archived vote dates
  vote_dates <-
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsCantonaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(date = lubridate::dmy(date),
                     is_election = stringr::str_detect(string = subject,
                                                       pattern = "(?i)^election"),
                     subject = subject)
  
  # incorporate latest vote dates (separate page)
  vote_dates %<>% dplyr::bind_rows(vote_dates_latest_neuchatel() %>%
                                     dplyr::filter(level == "cantonal") %>%
                                     dplyr::select(date,
                                                   is_election,
                                                   subject))
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    vote_dates %<>% dplyr::filter(!(!is_election
                                    & stringr::str_detect(string = subject,
                                                          pattern = regex_counterproposal_fr)))
  }
  
  # return cantonal vote dates or elections of the Council of States?
  regex <- "(?i)conseil\\s+des\\s+.tats"
  
  if (council_of_states) {
    
    vote_dates %<>% dplyr::filter((is_election
                                   & stringr::str_detect(string = subject,
                                                         pattern = regex)))
  } else {
    
    vote_dates %<>% dplyr::filter(!(is_election
                                    & stringr::str_detect(string = subject,
                                                          pattern = regex)))
  }
  
  vote_dates %>% dplyr::arrange(date, is_election)
}

get_neuchatel_municipal_vote_dates <- function(exclude_counterproposals = FALSE) {
  
  vote_dates <-
    # get archived vote dates
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsCommunaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(date = lubridate::dmy(date),
                     municipality =
                       subject %>%
                       stringr::str_extract(pattern = "^.+?(?= - )") %>%
                       stringr::str_replace_all(pattern = "Les Geneveys s/Coffrane",
                                                replacement = "Les Geneveys-sur-Coffrane"),
                     is_election =
                       subject %>%
                       stringr::str_detect(pattern = "(?i) - (e|\u00e9)lection"),
                     subject =
                       subject %>%
                       stringr::str_extract(pattern = "(?<= - ).*$")) %>%
    # incorporate latest vote dates (separate page)
    dplyr::bind_rows(vote_dates_latest_neuchatel() %>%
                       dplyr::filter(level == "municipal") %>%
                       dplyr::select(date,
                                     municipality,
                                     is_election,
                                     subject)) %>%
    # special cases @ 2008-06-22:
    # - split "La T\u00e8ne" into "Marin-Epagnier" & "Thielle-Wavre"
    # - split "Val-de-Travers" into "Boveresse", "Buttes", "Couvet", "Fleurier", "Les Bayards", "M\u00f4tiers", "Noiraigue", "Saint-Sulpice" & "Travers"
    # (municipality fusions weren't effective until 2009-01-01)
    dplyr::mutate(municipality = dplyr::case_when(municipality == "La T\u00e8ne" & date == "2008-06-22" ~ "Marin-Epagnier",
                                                  municipality == "Val-de-Travers" & date == "2008-06-22" ~ "Boveresse",
                                                  TRUE ~ municipality)) %>%
    tibble::add_row(date = "2008-06-22",
                    municipality = c("Thielle-Wavre",
                                     "Couvet",
                                     "Fleurier",
                                     "Les Bayards",
                                     "M\u00f4tiers",
                                     "Noiraigue",
                                     "Saint-Sulpice",
                                     "Travers"),
                    is_election = TRUE,
                    subject = c("Election au Conseil g\u00e9n\u00e9ral - La T\u00e8ne",
                                rep(x = "Election au Conseil g\u00e9n\u00e9ral - Val-de-Travers",
                                    times = 7L))) %>%
    dplyr::arrange(date, municipality)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    vote_dates %<>% dplyr::filter(!(!is_election
                                    & stringr::str_detect(string = subject,
                                                          pattern = regex_counterproposal_fr)))
  }
  
  vote_dates
}

get_geneva_referendum_dates <- function(years = 1996:lubridate::year(lubridate::today()),
                                        exclude_counterproposals = FALSE) {
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (year in years) {
    
    referendum_dates %<>% dplyr::bind_rows(get_geneva_referendum_date(year = year))
  }
  
  referendum_dates %<>%
    # ensure correct spelling of "Gen\u00e8ve"
    dplyr::mutate(municipality = dplyr::if_else(condition = municipality == "Geneve",
                                                true = "Gen\u00e8ve",
                                                false = municipality)) %>%
    # arrange columns
    dplyr::transmute(date, level, municipality, subject) %>%
    # arrange entries
    dplyr::arrange(date, level, municipality)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    ## define regex to catch them
    regex_counterproposal_only_fr <- "(?i)co?n?tre-?projet(?!\\s(direct|relatif))"
    
    ## define base proposal number regex
    regex_proposal_nr <- "(?i)(?<=\\bin(itiative)?(\\spopulaire)?(\\s|-|_|\\.)?)"
    
    ## get affected combos
    affected_date_proposal_combos <-
      referendum_dates %>%
      dplyr::mutate(proposal_nrs =
                      stringr::str_extract_all(string = subject,
                                               pattern = paste0(regex_proposal_nr, "\\d+")) %>%
                      # count only once per subject
                      purrr::map(unique)) %>%
      dplyr::group_by(date, level, municipality) %>%
      dplyr::summarise(proposal_nr =
                         proposal_nrs %>%
                         unlist() %>%
                         magrittr::extract(duplicated(.)) %>%
                         list()) %>%
      dplyr::ungroup() %>%
      tidyr::unnest()
    
    ## get affected entries
    to_exclude <- referendum_dates[0L, ]
    
    for (i in seq_len(nrow(affected_date_proposal_combos))) {
      
      to_exclude <-
        referendum_dates %>%
        dplyr::filter(date == affected_date_proposal_combos$date[i]
                      & level == affected_date_proposal_combos$level[i]
                      & (municipality == affected_date_proposal_combos$municipality[i]
                         | is.na(municipality) & is.na(affected_date_proposal_combos$municipality[i]))
                      # exclude explicitly numbered indirect counterproposals and tie-breaker questions
                      & ((stringr::str_detect(string = subject,
                                              pattern = paste0(regex_proposal_nr, affected_date_proposal_combos$proposal_nr[i]))
                          & stringr::str_detect(string = subject,
                                                pattern = regex_counterproposal_only_fr))
                         # exclude remaining tie-breaker questions
                         | stringr::str_detect(string = subject,
                                               pattern = "(?i)question\\ssubsidiaire"))) %>%
        dplyr::bind_rows(to_exclude)
    }
    
    ## exclude affected entries
    referendum_dates %<>%
      dplyr::setdiff(y = to_exclude) %>%
      # exclude some special cases (not having a proposal number)
      dplyr::filter(!(municipality == "Versoix" & date == "2009-05-17" & stringr::str_detect(string = subject,
                                                                                             pattern = "(?i)(contreprojet|question\\ssubsidiaire)")))
  }
  
  referendum_dates
}

get_geneva_referendum_date <- function(year) {
  
  if (year < 2007L) {
    
    referendum_dates <- scrape_geneva_referendum_dates_before_2007(year = year)
    
  } else if (year < 2015L) {
    
    referendum_dates <- scrape_geneva_referendum_dates_between_2007_2014(year = year)
    
  } else {
    
    referendum_dates <- scrape_geneva_referendum_dates_after_2014(year = year)
  }
  
  referendum_dates
}

get_geneva_referendum_dates_skeleton <- function() {
  
  tibble::tibble(date = lubridate::as_date(integer()),
                 level = character(),
                 municipality = character(),
                 subject = character())
}

scrape_geneva_referendum_dates_before_2007 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = paste0("https://www.ge.ch/votations/", year, ".asp"),
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure") %>%
    rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (i in seq_along(raw_extract)) {
    
    raw_subextract <-
      raw_extract[[i]] %>%
      rvest::html_nodes(css = "li")
    
    # exclude cancelled proposals (formatted struck through)
    is_cancelled <-
      raw_subextract %>%
      rvest::html_node(css = "span") %>%
      rvest::html_attr(name = "class") %>%
      magrittr::equals("txt_barre") %>%
      purrr::map_lgl(isTRUE)
    
    raw_subextract %<>%
      magrittr::extract(!is_cancelled) %>%
      rvest::html_nodes(css = "a") %>%
      # workaround to remove spurious 2006-11-26 link in 2005 page
      magrittr::extract(rvest::html_text(.) != "")
    
    if (length(raw_subextract)) {
      
      referendum_dates %<>%
        tibble::add_row(date =
                          raw_subextract %>%
                          rvest::html_attr(name = "href") %>%
                          stringr::str_extract(pattern = "\\d{8}") %>%
                          lubridate::ymd(),
                        level =
                          !!level[i],
                        subject =
                          raw_subextract %>%
                          rvest::html_text() %>%
                          stringr::str_squish(),
                        municipality =
                          dplyr::if_else(condition =
                                           level == "municipal",
                                         true =
                                           subject %>%
                                           stringr::str_extract(pattern = dplyr::if_else(condition = lubridate::year(date) != 2006L,
                                                                                         true = "^.+?(?=:)",
                                                                                         false = "(?<=\\s)\\S+$")),
                                         false = NA_character_))
    }
  }
  
  referendum_dates %>%
    # remove spurious entries
    dplyr::filter(!is.na(date) & !is.na(level)) %>%
    # special case 2005 (site structure differs): set correct `municipality`
    dplyr::mutate(municipality = dplyr::if_else(condition =
                                                  level == "municipal" &
                                                  lubridate::year(date) == 2005L,
                                                true = "Gen\u00e8ve",
                                                false = municipality))
}

scrape_geneva_referendum_dates_between_2007_2014 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = paste0("https://www.ge.ch/votations/", year, ".asp"),
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure")
  
  vote_locations_temp <-
    raw_extract %>%
    rvest::html_nodes(css = "h5") %>%
    rvest::html_text() %>%
    stringr::str_trim() %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$")
  
  raw_extract %<>%
    rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  vote_locations <- level
  vote_locations[!is.na(vote_locations)] <- vote_locations_temp
  rm(vote_locations_temp)
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  date <- lubridate::as_date(NA)
  
  for (i in seq_along(raw_extract)) {
    
    if (is.na(level[i])) {
      
      date <-
        raw_extract[[i]] %>%
        rvest::html_nodes(css = "li") %>%
        rvest::html_nodes(css = "a") %>%
        rvest::html_attr(name = "href") %>%
        stringr::str_extract(pattern = "\\d{8}") %>%
        lubridate::ymd()
      
    } else {
      
      raw_subextract <-
        raw_extract[[i]] %>%
        rvest::html_nodes(css = "li")
      
      # exclude cancelled proposals (formatted struck through)
      is_cancelled <-
        raw_subextract %>%
        rvest::html_node(css = "span") %>%
        rvest::html_attr(name = "class") %>%
        magrittr::equals("txt_barre") %>%
        purrr::map_lgl(isTRUE)
      
      raw_subextract %<>%
        magrittr::extract(!is_cancelled)
      
      if (length(raw_subextract)) {
        
        referendum_dates %<>% tibble::add_row(date = !!date,
                                              level = !!level[i],
                                              municipality = vote_locations[i],
                                              subject =
                                                raw_subextract %>%
                                                rvest::html_text() %>%
                                                stringr::str_squish())
      }
    }
  }
  
  # set `municipality` to NA again if `level` isn't municipal
  referendum_dates %>% dplyr::mutate(municipality = dplyr::if_else(condition = level == "municipal",
                                                                   true = municipality,
                                                                   false = NA_character_))
}

scrape_geneva_referendum_dates_after_2014 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = "https://www.ge.ch/votations/welcome.asp",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure") %>%
    rvest::html_nodes(css = "ul")
  
  is_relevant_year <-
    raw_extract %>%
    as.character() %>%
    stringr::str_extract(pattern = "\\d{8}") %>%
    lubridate::ymd() %>%
    lubridate::year() %>%
    magrittr::is_in(year)
  
  raw_extract %<>%
    magrittr::extract(is_relevant_year) %>%
    rvest::html_nodes(css = "li")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  ## process vote date specific subpages
  for (i in seq_along(raw_extract)) {
    
    href <-
      raw_extract[i] %>%
      rvest::html_nodes(css = "a") %>%
      rvest::html_attr(name = "href")
    
    # skip dates lacking a link to a subpage (supposedly preliminary)
    if (length(href)) {
      
      date <-
        href %>%
        stringr::str_extract(pattern = "\\d{8}") %>%
        lubridate::ymd()
      
      subpage_url <- paste0("https://www.ge.ch", href)
      
      # subpage format has changed from 2018-09-23 onwards
      if (date < "2018-09-23") {
        
        referendum_dates %<>% dplyr::bind_rows(scrape_geneva_referendum_date_between_2014_mid_2018(date = date,
                                                                                                   url = subpage_url))
      } else {
        
        referendum_dates %<>% dplyr::bind_rows(scrape_geneva_referendum_date_after_mid_2018(date = date,
                                                                                            url = subpage_url))
      }
    }
  }
  
  referendum_dates
}

scrape_geneva_referendum_date_between_2014_mid_2018 <- function(date,
                                                                url) {
  raw_extract <-
    xml2::read_html(x = url,
                    # subpage format has changed from 2018-09-23 onwards
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure")
  
  vote_locations <-
    raw_extract %>%
    rvest::html_nodes(css = "h4") %>%
    rvest::html_text() %>%
    stringr::str_trim() %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$")
  
  raw_extract %<>% rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (i in seq_along(raw_extract)) {
    
    if (!is.na(level[i])) {
      
      raw_subextract <-
        raw_extract[i] %>%
        rvest::html_nodes(css = "li")
      
      # exclude cancelled proposals (formatted struck through)
      is_cancelled <-
        raw_subextract %>%
        rvest::html_node(css = "span") %>%
        rvest::html_attr(name = "class") %>%
        magrittr::equals("txt_barre") %>%
        purrr::map_lgl(isTRUE)
      
      raw_subextract %<>%
        magrittr::extract(!is_cancelled)
      
      if (length(raw_subextract)) {
        
        referendum_dates %<>% tibble::add_row(date = !!date,
                                              level = !!level[i],
                                              municipality =
                                                dplyr::if_else(condition = level == "municipal",
                                                               true = vote_locations[i],
                                                               false = NA_character_),
                                              subject =
                                                raw_subextract %>%
                                                rvest::html_text() %>%
                                                stringr::str_squish())
      }
    }
  }
  
  referendum_dates
}

scrape_geneva_referendum_date_after_mid_2018 <- function(date,
                                                         url) {
  raw_extract <- xml2::read_html(x = url,
                                 # subpage format has changed from 2018-09-23 onwards
                                 encoding = "UTF-8")
  
  # get all "objet_*" selectors
  objet_selectors <-
    raw_extract %>%
    rvest::html_nodes(css = ".container") %>%
    rvest::html_nodes(css = "*") %>%
    rvest::html_attr("id") %>%
    unique() %>%
    magrittr::extract(stringr::str_detect(string = .,
                                          pattern = "^objet_")
                      & !is.na(.)) %>%
    paste0("#", .)
  
  vote_locations <-
    raw_extract %>%
    rvest::html_nodes(css = ".container") %>%
    rvest::html_nodes(css = "h2") %>%
    rvest::html_text() %>%
    magrittr::extract(!stringr::str_detect(string = .,
                                           pattern = "(?i)(documentation|(f\u00e9d\u00e9ra|cantona)(l|ux))")) %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$") %>%
    stringr::str_to_title() %>%
    # undo uppercasing of "middle words" (like the "La" in "Aire-La-Ville")
    gsub(pattern = "(-.+?-)",
         replacement = "\\L\\1",
         perl = TRUE)
  
  if (length(vote_locations) == 0L) vote_locations <- NA_character_
  
  subjects <-
    raw_extract %>%
    rvest::html_nodes(css = paste0(objet_selectors, collapse = ","))
  
  subjects <-
    subjects %>%
    rvest::html_nodes(css = "strong") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    paste(subjects %>%
            rvest::html_nodes(css = "small") %>%
            rvest::html_text() %>%
            stringr::str_squish(),
          sep = " \u2013 ")
  
  referendum_dates <- tibble::tibble(date = date,
                                     level =
                                       objet_selectors %>%
                                       stringr::str_extract(pattern = "(?<=^#objet_).+?(?=_)") %>%
                                       stringr::str_replace(pattern = "FED", replacement = "federal") %>%
                                       stringr::str_replace(pattern = "CAN", replacement = "cantonal") %>%
                                       stringr::str_replace(pattern = "COM", replacement = "municipal"),
                                     municipality = vote_locations,
                                     subject = subjects)
  
  referendum_dates
}

get_geneva_election_dates <- function() {
  
  raw_extract <-
    xml2::read_html(x = "https://www.ge.ch/elections/",
                    encoding = "UTF-8") %>%
    rvest::html_nodes(css = ".liste-lien") %>%
    rvest::html_nodes(css = "li") %>%
    rvest::html_nodes(css = "a") %>%
    # remove erroneous 2nd link @ 1993-10-17 (only visible in source)
    magrittr::extract(-72L)
  
  election_dates <-
    tibble::tibble(date =
                     raw_extract %>%
                     rvest::html_attr(name = "href") %>%
                     stringr::str_extract(pattern = "\\d{8}") %>%
                     lubridate::ymd(),
                   subject_summary =
                     raw_extract %>%
                     rvest::html_text() %>%
                     stringr::str_squish(),
                   is_federal =
                     stringr::str_detect(string = subject_summary,
                                         pattern = "(?i)(Conseil\\s+(des\\s+.tats|National)|f(\u00e9|e)d(\u00e9|e)rale)"),
                   is_cantonal =
                     !is_federal &
                     stringr::str_detect(string = subject_summary,
                                         pattern = paste0("(?i)(",
                                                          "Grand\\s+Conseil|Conseil(ler)?\\s+d.?.tat|Cour\\s+(des?\\s+comptes|d.?appel)",
                                                          "|^Elections\\s+judiciaires$",
                                                          "|Pouvoir\\s+Judiciaire",
                                                          "|Assembl(\u00e9|e)e\\s+constituante",
                                                          ")")),
                   is_municipal =
                     (!is_federal & !is_cantonal),
                   link =
                     raw_extract %>%
                     rvest::html_attr(name = "href") %>%
                     paste0(ifelse(test = stringr::str_detect(string = .,
                                                              pattern = "^https?://"),
                                   yes = "",
                                   no = "https://www.ge.ch/elections/"), .)) %>%
    dplyr::arrange(date)
  
  if (election_dates %>%
      dplyr::select(is_federal, is_cantonal, is_municipal) %>%
      rowSums() %>%
      magrittr::is_greater_than(1L) %>%
      any() %>%
      magrittr::not())
  {
    election_dates %<>% dplyr::transmute(date,
                                         level = dplyr::case_when(is_federal ~ "federal",
                                                                  is_cantonal ~ "cantonal",
                                                                  is_municipal ~ "municipal"),
                                         subject_summary,
                                         link)
    
  } else {
    rlang::abort("Elections on multiple levels at the same date detected! Please update the code of `get_geneva_election_dates()` to support this properly.")
  }
  
  election_dates
}

get_geneva_municipal_election_dates <- function() {
  
  genevan_municipalities <- municipalities(canton = "Geneva")
  
  election_dates <-
    get_geneva_election_dates() %>%
    dplyr::filter(level == "municipal") %>%
    dplyr::select(-level) %>%
    dplyr::mutate(municipality = NA_character_) %>%
    # fix URLs
    dplyr::mutate(link = stringr::str_remove(string = link,
                                             pattern = "res_cn_home.asp$"))
  
  additional_rows <- election_dates[0L, ]
  
  # determine municipalities ...
  for (i in seq_len(nrow(election_dates))) {
    
    # initialize potentially to replace subject summary
    new_subject_summaries <- character(0L)
    
    # ...  where already mentioned in subject summary ...
    matched_municipality <- genevan_municipalities[stringr::str_detect(string = election_dates$subject_summary[i],
                                                                       pattern = paste0("\\b", genevan_municipalities, "\\b"))]
    
    # ... or otherwise by inspecting the relevant subpages
    if (length(matched_municipality) == 0L) {
      
      matched_municipalities <- character()
      
      raw_extract <- xml2::read_html(x = election_dates$link[i],
                                     encoding = "UTF-8")
      
      # handle "normal" subpage layout
      try_to_match <-
        raw_extract %>%
        rvest::html_nodes(css = ".liste-lien") %>%
        rvest::html_nodes(css = "li") %>%
        rvest::html_nodes(css = "a")
      
      # handle different subpage layout (e.g. 2007-06-03)
      if (length(try_to_match) == 0L) {
        
        try_to_match <-
          raw_extract %>%
          rvest::html_nodes(css = ".content") %>%
          rvest::html_nodes(css = "h2")
      }
      
      try_to_match %<>%
        rvest::html_text() %>%
        stringr::str_squish()
      
      if (length(try_to_match)) {
        
        for (j in seq_along(try_to_match)) {
          
          matched_municipalities %<>%
            c(genevan_municipalities[stringr::str_detect(string = try_to_match[j],
                                                         pattern = paste0("\\b", genevan_municipalities, "\\b"))])
        }
      }
      
      if (length(matched_municipalities) == 0L) {
        
        # handle yet another subpage layout (-> one level deeper)
        subpage_links <-
          raw_extract %>%
          rvest::html_nodes(css = ".liste-lien") %>%
          rvest::html_nodes(css = "li") %>%
          rvest::html_nodes(css = "a") %>%
          rvest::html_attr(name = "href") %>%
          purrr::map_chr(~ paste0(election_dates$link[i], .x))
        
        for (link in subpage_links) {
          
          raw_extract <- xml2::read_html(x = link,
                                         encoding = "UTF-8")
          
          new_subject_summary <-
            raw_extract %>%
            rvest::html_nodes(css = ".content") %>%
            rvest::html_nodes(css = "h2") %>%
            rvest::html_text() %>%
            stringr::str_squish()
          
          if (length(new_subject_summary) != 1L) {
            
            rlang::abort("Unexpected scraping result! Please update the code of `get_geneva_municipal_election_dates()`.")
            
          } else {
            
            new_subject_summaries %<>% c(new_subject_summary)
          }
          
          try_to_match <-
            raw_extract %>%
            rvest::html_nodes(css = ".liste-lien") %>%
            rvest::html_nodes(css = "li") %>%
            rvest::html_nodes(css = "a") %>%
            rvest::html_text() %>%
            stringr::str_squish()
          
          if (length(try_to_match)) {
            
            for (j in seq_along(try_to_match))
            {
              matched_municipalities %<>% c(genevan_municipalities[stringr::str_detect(string = try_to_match[j],
                                                                                       pattern = paste0("\\b", genevan_municipalities, "\\b"))])
            }
          }
        }
        
        # assign 1st matched municipalitiy to original row ...
        matched_municipality <- matched_municipalities[1L]
        
        # ... and set the rest aside to append later on
        additional_rows %<>% tibble::add_row(date = election_dates$date[i],
                                             subject_summary =
                                               sapply(X = new_subject_summaries,
                                                      FUN = rep,
                                                      times = length(matched_municipalities) / length(new_subject_summaries),
                                                      simplify = FALSE) %>%
                                               unlist() %>%
                                               magrittr::extract(-1L),
                                             link = election_dates$link[i],
                                             municipality = matched_municipalities[-1L])
        
      } else {
        
        # assign 1st matched municipality to original row ...
        matched_municipality <- matched_municipalities[1L]
        
        # ... and set the rest aside to append later on
        additional_rows %<>% tibble::add_row(date = election_dates$date[i],
                                             subject_summary = election_dates$subject_summary[i],
                                             link = election_dates$link[i],
                                             municipality = matched_municipalities[2L:length(matched_municipalities)])
      }
    } else if (length(matched_municipality) > 1L) {
      
      rlang::abort("Multiple municipalities detected in `subject_summary`! Please update the code of `get_geneva_municipal_election_dates()`.")
    }
    
    election_dates$municipality[i] <- matched_municipality
    if (length(new_subject_summaries)) election_dates$subject_summary[i] <- new_subject_summaries[1L]
  }
  
  # append remaining municipalities
  election_dates %<>% dplyr::bind_rows(additional_rows)
  
  # remove duplicates (Corsier was sometimes archived later and thus appears twice in such cases)
  duplicate_indices <- integer()
  
  for (i in stringr::str_which(string = election_dates$link,
                               pattern = "^https://www\\.ge\\.ch/elections/\\d+?/.+$")) {
    
    if (election_dates$link[-i] %>%
        stringr::str_detect(pattern = paste0(stringr::str_extract(string = election_dates$link[i],
                                                                  pattern = "^https://www\\.ge\\.ch/elections/\\d+"),
                                             "/?$")) %>%
        any()) {
      
      duplicate_indices %<>% c(i)
    }
  }
  
  election_dates %>%
    dplyr::filter(!(dplyr::row_number(link) %in% duplicate_indices)) %>%
    # sort columns
    dplyr::transmute(date,
                     municipality,
                     subject = subject_summary) %>%
    # sort rows
    dplyr::arrange(date, municipality)
}

get_zurich_referendum_dates <- function(exclude_counterproposals = FALSE) {
  
  referendum_dates <-
    jsonlite::fromJSON(txt = "https://www.web.statistik.zh.ch/cms_abstimmungsarchiv/includes/ajax_get_vorlagen.php") %$%
    aaData %>%
    magrittr::set_colnames(ncol(.) %>% seq_len() %>% paste0("V", .)) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(id = as.integer(V1),
                     date = lubridate::dmy(V2),
                     level =
                       V3 %>%
                       stringr::str_extract(pattern = "(?<=title=\").+?(?=\")") %>%
                       stringr::str_replace_all(c("Eidgen\u00f6ssische Abstimmung" = "federal",
                                                  "Kantonale Abstimmung" = "cantonal")),
                     subject =
                       .$V4 %>%
                       paste0(collapse = "\n") %>%
                       xml2::read_html() %>%
                       rvest::html_text() %>%
                       stringr::str_split(pattern = "\n") %>%
                       unlist() %>%
                       stringr::str_squish(),
                     type = V5,
                     turnout =
                       V6 %>%
                       stringr::str_extract(pattern = "\\d+(\\.\\d+)?") %>%
                       as.numeric() %>%
                       magrittr::divide_by(100L),
                     yes_vote_share =
                       V7 %>%
                       stringr::str_extract(pattern = "\\d+(\\.\\d+)?") %>%
                       as.numeric() %>%
                       magrittr::divide_by(100L)) %>%
    dplyr::arrange(date, level, type)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    referendum_dates %<>% dplyr::filter(!stringr::str_detect(string = type,
                                                             pattern = "(^|:\\s+)(Gegenvorschlag|Stichfrage)"))
  }
  
  referendum_dates
}

get_zurich_municipal_vote_dates <- function(municipalities = NULL,
                                            exclude_counterproposals = FALSE) {
  
  valid_municipalities <- c("Bertschikon",
                            "Boppelsen",
                            "Bubikon",
                            "B\u00fclach",
                            "Fehraltorf",
                            "Kleinandelfingen",
                            "M\u00e4nnedorf",
                            "Maur",
                            "Mettmenstetten",
                            "Schlieren",
                            "Thalwil",
                            "Wiesendangen",
                            "Winterthur",
                            "Z\u00fcrich")
  
  if (is.null(municipalities)) municipalities <- valid_municipalities
  
  # check argument
  test_subset <- checkmate::check_subset(x = municipalities,
                                         choices = valid_municipalities)
  
  if (!isTRUE(test_subset)) {
    
    rlang::abort("Invalid argument provided: `municipalities`\n", test_subset)
  }
  
  unimplemented_municipalities <- c("Bertschikon",
                                    "Bubikon",
                                    "Fehraltorf",
                                    "Kleinandelfingen",
                                    "Wiesendangen")
  
  partially_implemented_municipalities <- c("B\u00fclach",
                                            "Maur")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (municipality in municipalities) {
    
    if (municipality %in% unimplemented_municipalities) {
      
      rlang::warn("Scraping vote dates from the municipality ", municipality,
                  " hasn't been implemented yet (or isn't even possible to implement). Therefore its municipal vote dates won't be included.")
      
    } else if (municipality %in% partially_implemented_municipalities) {
      
      rlang::warn("Scraping vote dates from the municipality ", municipality, " is only partially implemented so far and the structure of the returned data ",
                  "differs from the other municipalities. Therefore its municipal vote dates won't be included.")
    } else {
      
      # print a warning about missing election dates from Zurich
      if (municipality == "Z\u00fcrich") {
        
        rlang::warn("For the municipality ", municipality, " only referendum dates can be scraped. The municipal elections dates have to be gathered by hand.")
      }
      
      current_dates <- switch(EXPR = municipality,
                              "Boppelsen" = get_zurich_municipal_dates_boppelsen(),
                              "M\u00e4nnedorf" = get_zurich_municipal_dates_maennedorf(),
                              "Mettmenstetten" = get_zurich_municipal_dates_mettmenstetten(),
                              "Schlieren" = get_zurich_municipal_dates_schlieren(),
                              "Thalwil" = get_zurich_municipal_dates_thalwil(),
                              "Winterthur" = get_zurich_municipal_dates_winterthur(),
                              "Z\u00fcrich" = get_zurich_municipal_referendum_dates_zuerich(exclude_counterproposals = exclude_counterproposals))
      
      vote_dates %<>% dplyr::full_join(y = current_dates,
                                       by = colnames(current_dates))
    }
  }
  
  vote_dates %>% dplyr::arrange(date, municipality, is_election)
}

election_regex <- "(?i)(^Pfarrer\\s|\\b(Erneuerungs?|Ersatz|Pfarr)?wahl(en|gang|g\u00e4nge)?\\b)"

get_zurich_municipal_dates_generic <- function(municipality,
                                               base_url,
                                               start_date = "2000-01-01",
                                               municipal_types = c("bezirk", "kirchlich", "kommunal", "kreis", "verband")) {
  start_date %<>% lubridate::as_date()
  
  base_url %<>% paste0("?date_f=",
                       start_date %>% lubridate::day() %>% stringr::str_pad(width = 2L, side = "left", pad = "0"), ".",
                       start_date %>% lubridate::month() %>% stringr::str_pad(width = 2L, side = "left", pad = "0"), ".",
                       lubridate::year(start_date))
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (municipal_type in municipal_types) {
    
    raw_extract <-
      xml2::read_html(x = paste0(base_url, "&niveau=", municipal_type),
                      encoding = "windows-1252") %>%
      rvest::html_nodes(css = "table") %>%
      dplyr::last() %>%
      rvest::html_table() %>%
      tibble::as_tibble()
    
    if (all(c("Termin", "Titel der Vorlage") %in% colnames(raw_extract))) {
      
      vote_dates <-
        raw_extract %>%
        dplyr::transmute(date = lubridate::dmy(Termin),
                         municipality = !!municipality,
                         is_election = stringr::str_detect(string = `Titel der Vorlage`,
                                                           pattern = election_regex),
                         subject = `Titel der Vorlage`) %>%
        dplyr::bind_rows(vote_dates)
    }
  }
  
  if (nrow(vote_dates) == 0L) {
    
    rlang::abort("No <table> node of the expected structure was returned. You might have to update the `get_zurich_municipal_dates_generic()` function.")
  }
  
  vote_dates %>% dplyr::arrange(date, municipality, is_election)
}

get_zurich_municipal_dates_boppelsen <- function() {
  
  raw_extract <-
    xml2::read_html(x = "http://www.boppelsen.ch/gemeinde/politik/wahlen/archiv/default.htm",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = ".portletDocumentListWrapper")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  summary_texts <-
    raw_extract %>%
    rvest::html_nodes(css = "h3") %>%
    rvest::html_text()
  
  dates <-
    summary_texts %>%
    stringr::str_extract(pattern = "\\d+\\.\\s+\\S+\\s+\\d{4}(\\s+)?$") %>%
    lubridate::dmy()
  
  is_election_date <- stringr::str_detect(string = summary_texts,
                                          pattern = "(?i)wahl")
  
  raw_extract %<>% rvest::html_nodes(css = "ul")
  
  for (i in seq_along(dates)) {
    
    subject_part <-
      raw_extract[[i]] %>%
      rvest::html_nodes(css = "li") %>%
      rvest::html_nodes(css = "a") %>%
      rvest::html_attr(name = "title") %>%
      # filter non-municipal subjects
      magrittr::extract(!stringr::str_detect(string = .,
                                             pattern = "(?i)((national|st(\u00e4|ae)nde|kantons|regierungs)rat|eidge?n\u00f6ssis?che|kantonale)"))
    
    if (length(subject_part)) {
      
      vote_dates %<>% tibble::add_row(date = dates[i],
                                      municipality = "Boppelsen",
                                      is_election =
                                        is_election_date[i] &
                                        !stringr::str_detect(string = subject_part,
                                                             pattern = "(?i)(abstimmung|initiative|kredit|referendum|revision)"),
                                      subject = paste0(summary_texts[i], ": ", subject_part))
    }
  }
  
  vote_dates %>% dplyr::arrange(date, municipality, is_election)
}

get_zurich_municipal_dates_buelach <- function() {
  
  raw_extract <-
    xml2::read_html(x = "https://www.buelach.ch/themen/politik_verwaltung/wahlen_und_abstimmungen/wahlen_und_abstimmungen_resultate/",
                    encoding = "UTF-8") %>%
    rvest::html_nodes(css = ".element") %>%
    rvest::html_nodes(css = ".list") %>%
    dplyr::first() %>%
    rvest::html_nodes(css = "ul") %>%
    rvest::html_nodes(css = "li")
  
  tibble::tibble(date =
                   raw_extract %>%
                   rvest::html_nodes(css = ".date") %>%
                   rvest::html_text() %>%
                   lubridate::dmy(),
                 municipality = "B\u00fclach",
                 subject_summary =
                   raw_extract %>%
                   rvest::html_nodes(css = ".title") %>%
                   rvest::html_text(),
                 is_election_date = stringr::str_detect(string = subject_summary,
                                                        pattern = "(?i)wahl"),
                 link =
                   raw_extract %>%
                   rvest::html_nodes("a") %>%
                   rvest::html_attr(name = "href") %>%
                   paste0("https://www.buelach.ch/", .)) %>%
    dplyr::transmute(date, municipality, is_election_date, subject_summary, link) %>%
    dplyr::arrange(date, municipality, is_election_date)
}

get_zurich_municipal_dates_maennedorf <- function() {
  
  get_zurich_municipal_dates_generic(municipality = "M\u00e4nnedorf",
                                     base_url = "http://www.maennedorf.ch/de/politik/abstimmungsresultate/archivsuche/welcome.php")
}

get_zurich_municipal_dates_maur <- function() {
  
  raw_extract <-
    httr::POST(url = "http://www.maur.ch/xml_1/internet/de/file/modul/news/archiv.cfm?config=278ED4AB-5056-8276-9CEC654BDC655693&did=1&lid=1&lg=DE&userLG=DE",
               httr::user_agent(agent = "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"),
               httr::content_type(type = "application/x-www-form-urlencoded"),
               # `rubrik = 38` stands for the category "Wahlen / Abstimmungen"
               body = list(searchtype = "rub",
                           year = 0L,
                           month = 0L,
                           rubrik = 38L),
               encode = "form") %>%
    xml2::read_html(encoding = "UTF-8")
  
  vote_dates <-
    tibble::tibble(date =
                     raw_extract %>%
                     rvest::html_nodes(css = ".newsarchiv-date") %>%
                     rvest::html_text() %>%
                     lubridate::dmy(),
                   municipality = "Maur",
                   subject_summary =
                     raw_extract %>%
                     rvest::html_nodes(css = ".newsarchiv-title") %>%
                     rvest::html_text(),
                   is_election_date = stringr::str_detect(string = subject_summary,
                                                          pattern = "(?i)wahl"),
                   link =
                     raw_extract %>%
                     rvest::html_nodes(css = ".newsarchiv-title") %>%
                     rvest::html_nodes(css = "a") %>%
                     rvest::html_attr(name = "href") %>%
                     paste0("http://www.maur.ch/xml_1/internet/de/file/modul/news/", .)) %>%
    dplyr::transmute(date, municipality, is_election_date, subject_summary, link) %>%
    # filter some "false positives"
    dplyr::filter(!stringr::str_detect(string = subject_summary,
                                       pattern = "^(?i)(Formular\\s|Loorenprojekt:\\s)")) %>%
    # and sort
    dplyr::arrange(date, municipality, is_election_date)
  
  vote_dates
}

get_zurich_municipal_dates_mettmenstetten <- function() {
  
  get_zurich_municipal_dates_generic(
    municipality = "Mettmenstetten",
    base_url = "http://www.mettmenstetten.ch/de/politikverwaltung/abstimmungenundwahlen/abstimmungsresultate/archivsuche/welcome.php"
  )
}

get_zurich_municipal_dates_schlieren <- function() {
  
  get_zurich_municipal_dates_generic(municipality = "Schlieren",
                                     base_url = "http://www.schlieren.ch/de/politikverwaltung/politik/abstimmungsresultate/archivsuche/welcome.php")
}

get_zurich_municipal_dates_thalwil <- function() {
  
  get_zurich_municipal_dates_generic(municipality = "Thalwil",
                                     base_url = "http://www.thalwil.ch/de/polver/politik/abstimmungsresultate/politrechtevorlagen/welcome.php")
}

get_zurich_municipal_dates_winterthur <- function() {
  
  raw_extract <-
    xml2::read_html(x = "http://wahlen.winterthur.ch/archiv/vote-action/archive/vote-controller/ElectionDay/vote-year/9999/") %>%
    rvest::html_nodes(css = ".electionday-list") %>%
    rvest::html_nodes(css = ".row")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (i in seq_along(raw_extract)) {
    
    if (raw_extract[[i]] %>%
        rvest::html_nodes(css = ".col-8") %>%
        rvest::html_text() %>%
        stringr::str_squish() %>%
        magrittr::equals("Es sind noch keine Wahlen/Abstimmungen vorhanden") %>%
        magrittr::not()) {
      
      vote_dates %<>% tibble::add_row(date =
                                        raw_extract[[i]] %>%
                                        rvest::html_nodes(css = ".col-4") %>%
                                        rvest::html_text() %>%
                                        stringr::str_extract(pattern = "\\d+\\.\\d+\\.\\d{4}") %>%
                                        lubridate::dmy(),
                                      municipality = "Winterthur",
                                      subject =
                                        raw_extract[[i]] %>%
                                        rvest::html_nodes(css = ".col-8") %>%
                                        rvest::html_nodes(css = "ul") %>%
                                        rvest::html_nodes(css = "li") %>%
                                        rvest::html_text() %>%
                                        stringr::str_squish())
    }
  }
  
  vote_dates %>%
    dplyr::mutate(is_election = stringr::str_detect(string = subject,
                                                    pattern = election_regex)) %>%
    dplyr::arrange(date, municipality, is_election)
}

get_zurich_municipal_referendum_dates_zuerich <- function(exclude_counterproposals = FALSE) {
  
  referendum_dates <-
    readr::read_csv(file = paste0("https://data.stadt-zuerich.ch/dataset/politik_abstimmungen_seit_1933/resource/3b5a8ed9-0765-4d59-95a1-e87aa98350e3/",
                                  "download/abstimmungen_seit1933.csv"),
                    locale = readr::locale(encoding = "UTF-8",
                                           decimal_mark = "."),
                    col_types = "Dicciciciiidddcc") %>%
    dplyr::filter(Name_Politische_Ebene == "Stadt Z\u00fcrich") %>%
    dplyr::group_by(date = Abstimmungs_Datum,
                    municipality = "Z\u00fcrich",
                    is_election = FALSE,
                    subject = Abstimmungs_Text) %>%
    dplyr::summarise() %>%
    dplyr::arrange(date, municipality) %>%
    # manual corrections
    ## exclude duplicate entries
    dplyr::filter(
      ### @ 1996-06-09
      !((date == "1996-06-09"
         & subject == "A Wohnbauaktion (Rahmenkredit je 10 Mio. Franken) \nB Wohnbauaktion (Rahmenkredit je 20 Mio. Franken) \n Wohnbauaktion (Stichfrage)")
        ### @ 1981-01-25
        | (date == "1981-01-25"
           & subject == "Gegenvorschlag des Stadtrates zur Volksinitiative \u00fcber die Errichtung eines Gesundheitszentrums im Kreis 9"))
    )
  
  if (exclude_counterproposals) {
    
    referendum_dates %<>% dplyr::filter(!stringr::str_detect(string = subject,
                                                             pattern = "(?i)(^[bc][\\s\\.:)]|stichfrage)"))
  }
  
  referendum_dates
}

#' Retroactively merge municipalities that have merged
#'
#' This function builds upon [swissmuni::mutations()] to find municipalities in `data` that have merged into another municipality and synthetically applies
#' this merger "back in time" as best as possible. This allows subsequent data analysis to better track/compare the development of e-voting usage over time.
#'
#' @param data The data in which to perform the retroactive municipality mergers.
#'
#' @return `pkgsnip::return_label("data")`
#' @export
merge_municipalities <- function(data) {
  
  # process each *canton* individually and merge result
  data %>%
    dplyr::group_by(canton) %>%
    dplyr::group_split() %>%
    purrr::map_dfr(merge_municipalities_by_canton)
}

merge_municipalities_by_canton <- function(data_canton) {
  
  start_date <- min(data_canton$date,
                    na.rm = TRUE)
  
  end_date <- max(data_canton$date,
                  na.rm = TRUE)
  
  mutations <-
    swissmuni::mutations(start_date = start_date,
                         end_date = end_date,
                         cache_lifespan = "1 week") %>%
    # ensure data is ordered chronologically
    dplyr::arrange(MutationDate)
  
  # extract relevant "daughter" municipality codes
  mutations_daughters <-
    mutations %>%
    dplyr::filter(InitialCode %in% setdiff(data_canton$municipality_code, NA)) %>%
    dplyr::filter(TerminalCode %in% setdiff(data_canton$municipality_code, NA))
  
  # terminate early if no relevant "daughter" municipality codes found
  if (nrow(mutations_daughters)) {
    
    # extract relevant data (includes more rows when not all merged municipalities are present in our data)
    mutations_relevant <- mutations %>% dplyr::filter(MutationNumber %in% mutations_daughters$MutationNumber)
    
    # process each *date* individually and merge result
    data_canton %>%
      dplyr::group_by(date) %>%
      dplyr::group_split() %>%
      purrr::map_dfr(merge_municipalities_by_canton_date,
                     mutations_relevant = mutations_relevant)
    
  } else {
    data_canton
  }
}

merge_municipalities_by_canton_date <- function(data_canton_date,
                                                mutations_relevant) {
  
  # process each **municipality merger** (=MutationNumber) individually
  mutation_nrs <-
    mutations_relevant %>%
    dplyr::filter(InitialCode %in% intersect(mutations_relevant$InitialCode,
                                             data_canton_date$municipality_code)) %$%
    MutationNumber %>%
    unique()
  
  for (mutation_nr in mutation_nrs) {
    
    mutations_daughter <- mutations_relevant %>% dplyr::filter(MutationNumber == mutation_nr)
    ix_daughter <- which(data_canton_date$municipality_code %in% mutations_daughter$InitialCode)
    
    if (length(ix_daughter)) {
      
      # process each **group** individually
      merged_rows <-
        data_canton_date[ix_daughter, ] %>%
        dplyr::group_by(group) %>%
        dplyr::group_split() %>%
        purrr::map_dfr(merge_municipalities_helper,
                       municipality_code_new = unique(mutations_daughter$TerminalCode),
                       municipality_new = unique(mutations_daughter$TerminalName),
                       target_colnames = colnames(data_canton_date))
      
      data_canton_date %<>%
        dplyr::filter(!(dplyr::row_number() %in% ix_daughter)) %>%
        dplyr::bind_rows(merged_rows)
    }
  }
  
  data_canton_date
}

merge_municipalities_helper <- function(rows,
                                        municipality_code_new,
                                        municipality_new,
                                        target_colnames) {
  
  rows %>%
    dplyr::summarise(
      comments = paste0("Retroactively (i.e. synthetically) merged from the municipalities ", pal::prose_ls(municipality), "; ",
                        paste0(unique(comments),
                               collapse = "; ")),
      municipality_code = checkmate::assert_int(municipality_code_new),
      municipality_code_alt = NA_integer_,
      municipality = checkmate::assert_string(municipality_new),
      
      # cols which _should_ be identical
      dplyr::across(c(country,
                      canton,
                      district,
                      starts_with("system"),
                      date,
                      is_preregistration_required,
                      ends_with("_overlapping_aggregate"),
                      nr_of_federal_referendums,
                      nr_of_cantonal_referendums),
                    unique),
      
      # cols which have to be combined logically
      ## binary
      dplyr::across(c(is_entire_group_in_all_votes,
                      is_cross_vote_aggregated,
                      is_wassenaar_corrected,
                      is_matched_group),
                    all),
      ## 3-code
      dplyr::across(c(type,
                      federal_elected_power,
                      matches("^(federal|cantonal|municipal|combined)_election_procedure$")),
                    determine_3_code_combo),
      ## group (6-code)
      group = combine_group(group),
      ## 7-code
      dplyr::across(c(matches("^(referendum|election|combined)_level$"),
                      matches("^(cantonal|municipal|combined)_elected_power$")),
                    determine_7_code_combo),
      
      # cols which have to be summed up
      dplyr::across(c(e_voting_electorate,
                      total_electorate,
                      vote_count_e_voting_electorate,
                      ballot_votes_e_voting_electorate,
                      postal_votes_e_voting_electorate,
                      vote_count_total,
                      ballot_votes_total,
                      postal_votes_total,
                      e_votes),
                    ~ dplyr::if_else(all(is.na(.x)),
                                     NA_integer_,
                                     sum(.x,
                                         na.rm = TRUE))),
      dplyr::across(c(matched_group_notes,
                      source),
                    ~ paste0(unique(.x),
                             collapse = "; ")),
      
      # other cols
      nr_of_municipal_referendums = max(nr_of_cantonal_referendums,
                                        na.rm = TRUE)
    ) %>%
    # cols which have to be recalculated
    dplyr::mutate(total_nr_of_referendums = sum(nr_of_federal_referendums,
                                                nr_of_cantonal_referendums,
                                                nr_of_municipal_referendums,
                                                na.rm = TRUE),
                  group_name = get_group_name(group),
                  type_name = get_type_name(type),
                  referendum_level_name = get_level_name(referendum_level),
                  election_level_name = get_level_name(election_level),
                  combined_level_name = get_level_name(combined_level),
                  federal_elected_power_name = get_federal_elected_power_name(federal_elected_power),
                  cantonal_elected_power_name = get_elected_power_name(cantonal_elected_power),
                  municipal_elected_power_name = get_elected_power_name(municipal_elected_power),
                  combined_elected_power_name = get_elected_power_name(combined_elected_power),
                  federal_election_procedure_name = get_election_procedure_name(federal_election_procedure),
                  cantonal_election_procedure_name = get_election_procedure_name(cantonal_election_procedure),
                  municipal_election_procedure_name = get_election_procedure_name(municipal_election_procedure),
                  combined_election_procedure_name = get_election_procedure_name(combined_election_procedure),
                  
                  turnout = vote_count_e_voting_electorate / e_voting_electorate,
                  ballot_votes_share = ballot_votes_e_voting_electorate / vote_count_e_voting_electorate,
                  postal_votes_share = postal_votes_e_voting_electorate / vote_count_e_voting_electorate,
                  e_votes_share = e_votes / vote_count_e_voting_electorate,
                  e_votes_share_total_electorate = e_votes / total_electorate,
                  e_votes_share_e_voting_electorate = e_votes / e_voting_electorate) %>%
    # fix col order
    dplyr::select(all_of(target_colnames)) %>%
    # fix name of GE municipality "La Grande BÃ©roche" (hyphen was dropped)
    dplyr::mutate(municipality = dplyr::if_else(municipality == "La Grande-B\u00e9roche",
                                                "La Grande B\u00e9roche",
                                                municipality))
}
