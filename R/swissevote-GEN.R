# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/swissevote.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = c(".",
                                 "aaData",
                                 "Abstimmungs_Datum",
                                 "Abstimmungs_Text",
                                 "is_cantonal",
                                 "is_election",
                                 "is_election_date",
                                 "is_federal",
                                 "is_municipal",
                                 "level",
                                 "limited_to_cantons",
                                 "link",
                                 "municipality",
                                 "Name_Politische_Ebene",
                                 "proposal_nrs",
                                 "subject",
                                 "subject_summary",
                                 "Termin",
                                 "Titel der Vorlage",
                                 "type",
                                 "V1",
                                 "V2",
                                 "V3",
                                 "V5",
                                 "V6",
                                 "V7"))

pkg <- utils::packageName()

regex_counterproposal_fr <- "(?i)(co?n?tre-?projet(?!\\s(direct|relatif))|question\\ssubsidiaire)"

e_voting_cantons <- tibble::tribble(
         ~canton, ~canton_short,
       "Argovia",          "AG",
    "Basel-City",          "BS",
          "Bern",          "BE",
      "Fribourg",          "FR",
        "Geneva",          "GE",
        "Glarus",          "GL",
       "Grisons",          "GR",
       "Lucerne",          "LU",
     "Neuchatel",          "NE",
  "Schaffhausen",          "SH",
     "Solothurn",          "SO",
    "St. Gallen",          "SG",
       "Thurgau",          "TG",
          "Vaud",          "VD",
        "Zurich",          "ZH"
  )

municipalities <- function(canton = c("Geneva", "Neuchatel", "Zurich")) {
  
  switch(EXPR = rlang::arg_match(canton),
         "Geneva" = c("Ani\u00e8res",
                      "Cologny",
                      "Carouge",
                      "Meyrin",
                      "Vandoeuvres",
                      "Collonge-Bellerive",
                      "Onex",
                      "Versoix",
                      "Bernex",
                      "Ch\u00eane-Bourg",
                      "Grand-Saconnex",
                      "Lancy",
                      "Th\u00f4nex",
                      "Vernier",
                      "Perly-Certoux",
                      "Plan-les-Ouates",
                      "Ch\u00eane-Bougeries",
                      "Avusy",
                      "Aire-la-Ville",
                      "Troinex",
                      "Avully",
                      "Bardonnex",
                      "Bellevue",
                      "Cartigny",
                      "C\u00e9ligny",
                      "Chancy",
                      "Choulex",
                      "Collex-Bossy",
                      "Confignon",
                      "Corsier",
                      "Dardagny",
                      "Gen\u00e8ve",
                      "Genthod",
                      "Gy",
                      "Hermance",
                      "Jussy",
                      "Laconnex",
                      "Meinier",
                      "Pregny-Chamb\u00e9sy",
                      "Presinge",
                      "Puplinge",
                      "Russin",
                      "Satigny",
                      "Soral",
                      "Veyrier"),
         rlang::abort("Not implemented yet."))
}

#' Convert between full canton names and their two-letter abbreviations
#'
#' @param cantons The full names or two-letter abbreviations of the cantons to be converted. A character vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' convert_canton_names(c("ZH", "VD", "AG"))
#' convert_canton_names(c("Zurich", "Vaud", "Argovia"))
#' convert_canton_names(c("ZH", "Vaud", "Argovia"))
convert_canton_names <- function(cantons) {
  
  converted_names <- character()
  
  for (canton_name in checkmate::assert_character(cantons,
                                                  any.missing = FALSE)) {
    
    long_match <- match(x = canton_name,
                        table = e_voting_cantons$canton)
    short_match <- match(x = canton_name,
                         table = e_voting_cantons$canton_short)
    
    if (!is.na(long_match)) {
      
      converted_names %<>% c(e_voting_cantons$canton_short[long_match])
      
    } else if (!is.na(short_match)) {
      
      converted_names %<>% c(e_voting_cantons$canton[short_match])
      
    } else rlang::abort(glue::glue("`{canton_name}` is not a valid e-voting canton."))
  }
  
  converted_names
}

vote_dates_latest_neuchatel <- function() {
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               level = character(),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  raw_extract <-
    xml2::read_html(x = "https://www2.ne.ch/vote",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "table") %>%
    magrittr::extract2(4L) %>%
    rvest::html_nodes(css = "td")
  
  level_i <- NA
  
  for (i in seq_along(raw_extract)) {
    
    if (isTRUE(rvest::html_attr(x = raw_extract[[i]],
                                name = "class") == "VotationType")) {
      
      level_i <- switch(EXPR = rvest::html_text(x = raw_extract[[i]]),
                        "Scrutins f\u00e9d\u00e9raux" = "federal",
                        "Scrutins cantonaux" = "cantonal",
                        "Scrutins communaux" = "municipal")
      
    } else if (isTRUE(raw_extract[[i]] %>%
                      rvest::html_nodes(css = "a") %>%
                      rvest::html_attr(name = "class") %>%
                      magrittr::equals("SubSectionTitle"))
               & !is.na(level_i)) {
      
      text_i <-
        raw_extract[[i]] %>%
        rvest::html_text() %>%
        stringr::str_squish() %>%
        stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                             replacement = "\\1 \\4\\2") %>%
        stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                           simplify = FALSE) %>%
        purrr::flatten_chr()
      
      vote_dates %<>% tibble::add_row(date = lubridate::dmy(text_i[2L]),
                                      level = level_i,
                                      municipality = dplyr::if_else(condition = level == "municipal",
                                                                    true =
                                                                      text_i[1L] %>%
                                                                      stringr::str_extract(pattern = "^.+?(?= - )") %>%
                                                                      stringr::str_replace_all(pattern = "Les Geneveys s/Coffrane",
                                                                                               replacement = "Les Geneveys-sur-Coffrane"),
                                                                    false = NA_character_),
                                      is_election = stringr::str_detect(string = text_i[1L],
                                                                        pattern = "(?i) - (e|\u00e9)lection"),
                                      subject = dplyr::if_else(condition = level == "municipal",
                                                               true = stringr::str_extract(string = text_i[1L],
                                                                                           pattern = "(?<= - ).*$"),
                                                               false = text_i[1L]))
    }
  }
  
  vote_dates %>% dplyr::arrange(date, level, is_election)
}

#' Get federal vote dates
#'
#' @param source Federal vote dates can either be retrieved from the official website of the canton of _Neuchatel_ (default) or _Zurich_. Note that only
#'   referendum dates will be returned from `source = "Zurich"`, election dates can only be scraped from `source = "Neuchatel"`. On the other hand,
#'   `source = "Zurich"` will return referendum dates back to the 19th century, while `source = "Neuchatel"` only goes back to the turn of the millennium.
#' @param exclude_counterproposals Exclude indirect counterproposals and tie-breaker questions. A logical scalar.
#' @param use_cache `pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `pkgsnip::param_label("cache_lifespan")`
#'
#' @return `pkgsnippets::return_label("data")`
#' @export
vote_dates_federal <- function(source = c("Neuchatel", "Zurich"),
                               exclude_counterproposals = TRUE,
                               use_cache = TRUE,
                               cache_lifespan = "1 day") {
  
  pkgpins::with_cache(
    fn = function(source,
                  exclude_counterproposals) {
      
      result <- switch(EXPR = source,
                       "Neuchatel" =
                         vote_dates_federal_neuchatel(exclude_counterproposals = exclude_counterproposals),
                       "Zurich" =
                         get_zurich_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                         dplyr::filter(level == "federal") %>%
                         dplyr::select(date, subject) %>%
                         dplyr::transmute(date,
                                          is_election = FALSE,
                                          limited_to_cantons = NA,
                                          subject))
      
      # incorporate GE Council of States vote dates
      result %>%
        dplyr::bind_rows(get_geneva_election_dates() %>%
                           dplyr::filter(level == "federal"
                                         & !(date %in% result$date)
                                         & date > min(result$date)) %>%
                           dplyr::transmute(date,
                                            is_election = TRUE,
                                            limited_to_cantons = "Geneva",
                                            subject = subject_summary)) %>%
        dplyr::arrange(date, is_election)
    },
    source = rlang::arg_match(source),
    exclude_counterproposals = exclude_counterproposals,
    use_cache = use_cache,
    cache_lifespan = cache_lifespan,
    pkg = pkg
  )
}

vote_dates_federal_neuchatel <- function(exclude_counterproposals = FALSE) {
  
  # get archived vote dates
  vote_dates <-
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsFederaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(date = lubridate::dmy(date),
                     is_election = stringr::str_detect(string = subject,
                                                       pattern = "(?i)^(e|\u00e9)lection"),
                     limited_to_cantons = NA,
                     subject = subject)
  
  # incorporate latest vote dates (separate page)
  vote_dates %<>% dplyr::bind_rows(vote_dates_latest_neuchatel() %>%
                                     dplyr::filter(level == "federal") %>%
                                     dplyr::transmute(date,
                                                      is_election,
                                                      limited_to_cantons = NA,
                                                      subject))
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    vote_dates %<>%
      dplyr::filter(!(!is_election
                      & stringr::str_detect(string = subject,
                                            pattern = regex_counterproposal_fr))) %>%
      # manually exclude remaining cases
      dplyr::filter(!(date == "2002-09-22"
                     & subject == "L'or \u00e0 l'AVS, aux cantons et \u00e0 la Fondation\""))
  }
  
  # incorporate Council of States election dates
  vote_dates %>%
    dplyr::filter(is_election) %>%
    dplyr::bind_rows(get_neuchatel_cantonal_vote_dates(council_of_states = TRUE) %>%
                       dplyr::transmute(date,
                                        is_election,
                                        limited_to_cantons = dplyr::if_else(condition = date %in% vote_dates$date,
                                                                            true = NA_character_,
                                                                            false = "Neuchatel"),
                                        subject)) %>%
    dplyr::group_by(date, is_election, limited_to_cantons) %>%
    dplyr::summarise(subject = paste0(subject,
                                      collapse = "; "),
                     .groups = "drop") %>%
    dplyr::bind_rows(vote_dates %>% dplyr::filter(!is_election)) %>%
    dplyr::arrange(date, is_election)
}

#' Get cantonal vote dates
#'
#' @param cantons The names of the cantons to retrieve vote dates for. A character vector.
#' @inheritParams vote_dates_federal
#'
#' @inherit vote_dates_federal return
#' @export
vote_dates_cantonal <- function(cantons = c("Geneva", "Neuchatel", "Zurich"),
                                exclude_counterproposals = TRUE,
                                use_cache = TRUE,
                                cache_lifespan = "1 day") {
  
  pkgpins::with_cache(
    fn = function(cantons,
                  exclude_counterproposals) {
      
      vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                                   canton = character(),
                                   is_election = logical(),
                                   subject = character())
      
      for (canton in cantons) {
        
        # print warning ...
        switch(
          EXPR = canton,
          # ... about missing ZH election dates
          "Zurich" = rlang::warn("For the Canton of ", canton,
                                 " only referendum dates can be scraped. The cantonal election dates have to be gathered by hand.")
        )
        
        if (canton %in% c("Neuchatel", "Zurich")) {
          
          vote_dates <-
            switch(EXPR = canton,
                   "Geneva" =
                     get_geneva_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::filter(level == "cantonal") %>%
                     dplyr::transmute(date,
                                      subject,
                                      is_election = FALSE) %>%
                     dplyr::bind_rows(get_geneva_election_dates() %>%
                                        dplyr::filter(level == "cantonal") %>%
                                        dplyr::transmute(date,
                                                         subject = subject_summary,
                                                         is_election = TRUE)) %>%
                     dplyr::mutate(canton = "Geneva"),
                   "Neuchatel" =
                     get_neuchatel_cantonal_vote_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::mutate(canton = "Neuchatel"),
                   "Zurich" =
                     get_zurich_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::filter(level == "cantonal") %>%
                     dplyr::mutate(canton = "Zurich",
                                   is_election = FALSE) %>%
                     dplyr::select(date, canton, is_election, subject),
                   tibble::tibble(date = lubridate::as_date(integer()),
                                  canton = character(),
                                  is_election = logical(),
                                  subject = character())) %>%
            dplyr::transmute(date, canton, is_election, subject) %>%
            dplyr::full_join(y = vote_dates,
                             by = colnames(vote_dates))
        } else {
          rlang::warn("Scraping vote dates from the canton of ", canton, " hasn't been implemented yet!")
        }
      }
      
      vote_dates %>% dplyr::arrange(date, canton, is_election)
    },
    cantons = cantons,
    exclude_counterproposals = exclude_counterproposals,
    use_cache = use_cache,
    cache_lifespan = cache_lifespan,
    pkg = pkg
  )
}

#' Get municipal vote dates
#'
#' @inheritParams vote_dates_cantonal
#' @inheritParams vote_dates_federal
#'
#' @inherit vote_dates_federal return
#' @export
vote_dates_municipal <- function(cantons = c("Geneva", "Neuchatel", "Zurich"),
                                 exclude_counterproposals = TRUE,
                                 use_cache = TRUE,
                                 cache_lifespan = 86400L) {
  
  supported_cantons <- c("Geneva", "Neuchatel", "Zurich")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               canton = character(),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (canton in cantons) {
    
    cached_filepath <- paste0("backup/municipal_vote_dates_", convert_canton_names(canton), ".csv")
    
    # if `cached = TRUE` and last download was less than `cache_lifespan` seconds ago, read in cached data, otherwise download it from web
    if ((!use_cache |
         !file.exists(cached_filepath) |
         file.size(cached_filepath) == 0 |
         ((file.mtime(cached_filepath) + lubridate::dseconds(x = cache_lifespan)) < lubridate::now()))
        & canton %in% supported_cantons) {
      
      current_vote_dates <-
        switch(EXPR = canton,
               
               "Geneva" =
                 get_geneva_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                 dplyr::filter(level == "municipal") %>%
                 dplyr::transmute(date,
                                  municipality,
                                  is_election = FALSE,
                                  subject) %>%
                 dplyr::bind_rows(get_geneva_municipal_election_dates() %>%
                                    dplyr::transmute(date,
                                                     municipality,
                                                     is_election = TRUE,
                                                     subject)) %>%
                 dplyr::mutate(canton = "Geneva"),
               
               "Neuchatel" =
                 get_neuchatel_municipal_vote_dates(exclude_counterproposals = exclude_counterproposals) %>%
                 dplyr::mutate(canton = "Neuchatel"),
               
               "Zurich" =
                 get_zurich_municipal_vote_dates(exclude_counterproposals = exclude_counterproposals) %>%
                 dplyr::mutate(canton = "Zurich")) %>%
        dplyr::transmute(date, canton, municipality, is_election, subject)
      
      readr::write_csv(x = current_vote_dates,
                       path = cached_filepath)
      
      vote_dates %<>% dplyr::full_join(y = current_vote_dates,
                                       by = colnames(.))
      
    } else if (canton %in% supported_cantons) {
      
      vote_dates %<>% dplyr::full_join(y = readr::read_csv(file = cached_filepath,
                                                           col_types = "Dcclc"),
                                       by = colnames(.))
    } else {
      
      # print warning about unsupported cantons
      rlang::warn("Scraping vote dates from the Canton of ", canton, " hasn't been implemented yet!")
    }
  }
  
  vote_dates %>% dplyr::arrange(date, canton, municipality, is_election)
}

get_neuchatel_cantonal_vote_dates <- function(council_of_states = FALSE,
                                              exclude_counterproposals = FALSE) {
  # get archived vote dates
  vote_dates <-
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsCantonaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(date = lubridate::dmy(date),
                     is_election = stringr::str_detect(string = subject,
                                                       pattern = "(?i)^election"),
                     subject = subject)
  
  # incorporate latest vote dates (separate page)
  vote_dates %<>% dplyr::bind_rows(vote_dates_latest_neuchatel() %>%
                                     dplyr::filter(level == "cantonal") %>%
                                     dplyr::select(date,
                                                   is_election,
                                                   subject))
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    vote_dates %<>% dplyr::filter(!(!is_election
                                    & stringr::str_detect(string = subject,
                                                          pattern = regex_counterproposal_fr)))
  }
  
  # return cantonal vote dates or elections of the Council of States?
  regex <- "(?i)conseil\\s+des\\s+.tats"
  
  if (council_of_states) {
    
    vote_dates %<>% dplyr::filter((is_election
                                   & stringr::str_detect(string = subject,
                                                         pattern = regex)))
  } else {
    
    vote_dates %<>% dplyr::filter(!(is_election
                                    & stringr::str_detect(string = subject,
                                                          pattern = regex)))
  }
  
  vote_dates %>% dplyr::arrange(date, is_election)
}

get_neuchatel_municipal_vote_dates <- function(exclude_counterproposals = FALSE) {
  
  vote_dates <-
    # get archived vote dates
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsCommunaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(date = lubridate::dmy(date),
                     municipality =
                       subject %>%
                       stringr::str_extract(pattern = "^.+?(?= - )") %>%
                       stringr::str_replace_all(pattern = "Les Geneveys s/Coffrane",
                                                replacement = "Les Geneveys-sur-Coffrane"),
                     is_election =
                       subject %>%
                       stringr::str_detect(pattern = "(?i) - (e|\u00e9)lection"),
                     subject =
                       subject %>%
                       stringr::str_extract(pattern = "(?<= - ).*$")) %>%
    # incorporate latest vote dates (separate page)
    dplyr::bind_rows(vote_dates_latest_neuchatel() %>%
                       dplyr::filter(level == "municipal") %>%
                       dplyr::select(date,
                                     municipality,
                                     is_election,
                                     subject)) %>%
    # special cases @ 2008-06-22:
    # - split "La T\u00e8ne" into "Marin-Epagnier" & "Thielle-Wavre"
    # - split "Val-de-Travers" into "Boveresse", "Buttes", "Couvet", "Fleurier", "Les Bayards", "M\u00f4tiers", "Noiraigue", "Saint-Sulpice" & "Travers"
    # (municipality fusions weren't effective until 2009-01-01)
    dplyr::mutate(municipality = dplyr::case_when(municipality == "La T\u00e8ne" & date == "2008-06-22" ~ "Marin-Epagnier",
                                                  municipality == "Val-de-Travers" & date == "2008-06-22" ~ "Boveresse",
                                                  TRUE ~ municipality)) %>%
    tibble::add_row(date = "2008-06-22",
                    municipality = c("Thielle-Wavre",
                                     "Couvet",
                                     "Fleurier",
                                     "Les Bayards",
                                     "M\u00f4tiers",
                                     "Noiraigue",
                                     "Saint-Sulpice",
                                     "Travers"),
                    is_election = TRUE,
                    subject = c("Election au Conseil g\u00e9n\u00e9ral - La T\u00e8ne",
                                rep(x = "Election au Conseil g\u00e9n\u00e9ral - Val-de-Travers",
                                    times = 7L))) %>%
    dplyr::arrange(date, municipality)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    vote_dates %<>% dplyr::filter(!(!is_election
                                    & stringr::str_detect(string = subject,
                                                          pattern = regex_counterproposal_fr)))
  }
  
  vote_dates
}

get_geneva_referendum_dates <- function(years = 1996:lubridate::year(lubridate::today()),
                                        exclude_counterproposals = FALSE) {
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (year in years) {
    
    referendum_dates %<>% dplyr::bind_rows(get_geneva_referendum_date(year = year))
  }
  
  referendum_dates %<>%
    # ensure correct spelling of "Gen\u00e8ve"
    dplyr::mutate(municipality = dplyr::if_else(condition = municipality == "Geneve",
                                                true = "Gen\u00e8ve",
                                                false = municipality)) %>%
    # arrange columns
    dplyr::transmute(date, level, municipality, subject) %>%
    # arrange entries
    dplyr::arrange(date, level, municipality)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    ## define regex to catch them
    regex_counterproposal_only_fr <- "(?i)co?n?tre-?projet(?!\\s(direct|relatif))"
    
    ## define base proposal number regex
    regex_proposal_nr <- "(?i)(?<=\\bin(itiative)?(\\spopulaire)?(\\s|-|_|\\.)?)"
    
    ## get affected combos
    affected_date_proposal_combos <-
      referendum_dates %>%
      dplyr::mutate(proposal_nrs =
                      stringr::str_extract_all(string = subject,
                                               pattern = paste0(regex_proposal_nr, "\\d+")) %>%
                      # count only once per subject
                      purrr::map(unique)) %>%
      dplyr::group_by(date, level, municipality) %>%
      dplyr::summarise(proposal_nr =
                         proposal_nrs %>%
                         unlist() %>%
                         magrittr::extract(duplicated(.)) %>%
                         list()) %>%
      dplyr::ungroup() %>%
      tidyr::unnest()
    
    ## get affected entries
    to_exclude <- referendum_dates[0L, ]
    
    for (i in seq_len(nrow(affected_date_proposal_combos))) {
      
      to_exclude <-
        referendum_dates %>%
        dplyr::filter(date == affected_date_proposal_combos$date[i]
                      & level == affected_date_proposal_combos$level[i]
                      & (municipality == affected_date_proposal_combos$municipality[i]
                         | is.na(municipality) & is.na(affected_date_proposal_combos$municipality[i]))
                      # exclude explicitly numbered indirect counterproposals and tie-breaker questions
                      & ((stringr::str_detect(string = subject,
                                              pattern = paste0(regex_proposal_nr, affected_date_proposal_combos$proposal_nr[i]))
                          & stringr::str_detect(string = subject,
                                                pattern = regex_counterproposal_only_fr))
                         # exclude remaining tie-breaker questions
                         | stringr::str_detect(string = subject,
                                               pattern = "(?i)question\\ssubsidiaire"))) %>%
        dplyr::bind_rows(to_exclude)
    }
    
    ## exclude affected entries
    referendum_dates %<>%
      dplyr::setdiff(y = to_exclude) %>%
      # exclude some special cases (not having a proposal number)
      dplyr::filter(!(municipality == "Versoix" & date == "2009-05-17" & stringr::str_detect(string = subject,
                                                                                             pattern = "(?i)(contreprojet|question\\ssubsidiaire)")))
  }
  
  referendum_dates
}

get_geneva_referendum_date <- function(year) {
  
  if (year < 2007L) {
    
    referendum_dates <- scrape_geneva_referendum_dates_before_2007(year = year)
    
  } else if (year < 2015L) {
    
    referendum_dates <- scrape_geneva_referendum_dates_between_2007_2014(year = year)
    
  } else {
    
    referendum_dates <- scrape_geneva_referendum_dates_after_2014(year = year)
  }
  
  referendum_dates
}

get_geneva_referendum_dates_skeleton <- function() {
  
  tibble::tibble(date = lubridate::as_date(integer()),
                 level = character(),
                 municipality = character(),
                 subject = character())
}

scrape_geneva_referendum_dates_before_2007 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = paste0("https://www.ge.ch/votations/", year, ".asp"),
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure") %>%
    rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (i in seq_along(raw_extract)) {
    
    raw_subextract <-
      raw_extract[[i]] %>%
      rvest::html_nodes(css = "li")
    
    # exclude cancelled proposals (formatted struck through)
    is_cancelled <-
      raw_subextract %>%
      rvest::html_node(css = "span") %>%
      rvest::html_attr(name = "class") %>%
      magrittr::equals("txt_barre") %>%
      purrr::map_lgl(isTRUE)
    
    raw_subextract %<>%
      magrittr::extract(!is_cancelled) %>%
      rvest::html_nodes(css = "a") %>%
      # workaround to remove spurious 2006-11-26 link in 2005 page
      magrittr::extract(rvest::html_text(.) != "")
    
    if (length(raw_subextract)) {
      
      referendum_dates %<>%
        tibble::add_row(date =
                          raw_subextract %>%
                          rvest::html_attr(name = "href") %>%
                          stringr::str_extract(pattern = "\\d{8}") %>%
                          lubridate::ymd(),
                        level =
                          !!level[i],
                        subject =
                          raw_subextract %>%
                          rvest::html_text() %>%
                          stringr::str_squish(),
                        municipality =
                          dplyr::if_else(condition =
                                           level == "municipal",
                                         true =
                                           subject %>%
                                           stringr::str_extract(pattern = dplyr::if_else(condition = lubridate::year(date) != 2006L,
                                                                                         true = "^.+?(?=:)",
                                                                                         false = "(?<=\\s)\\S+$")),
                                         false = NA_character_))
    }
  }
  
  referendum_dates %>%
    # remove spurious entries
    dplyr::filter(!is.na(date) & !is.na(level)) %>%
    # special case 2005 (site structure differs): set correct `municipality`
    dplyr::mutate(municipality = dplyr::if_else(condition =
                                                  level == "municipal" &
                                                  lubridate::year(date) == 2005L,
                                                true = "Gen\u00e8ve",
                                                false = municipality))
}

scrape_geneva_referendum_dates_between_2007_2014 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = paste0("https://www.ge.ch/votations/", year, ".asp"),
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure")
  
  vote_locations_temp <-
    raw_extract %>%
    rvest::html_nodes(css = "h5") %>%
    rvest::html_text() %>%
    stringr::str_trim() %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$")
  
  raw_extract %<>%
    rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  vote_locations <- level
  vote_locations[!is.na(vote_locations)] <- vote_locations_temp
  rm(vote_locations_temp)
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  date <- lubridate::as_date(NA)
  
  for (i in seq_along(raw_extract)) {
    
    if (is.na(level[i])) {
      
      date <-
        raw_extract[[i]] %>%
        rvest::html_nodes(css = "li") %>%
        rvest::html_nodes(css = "a") %>%
        rvest::html_attr(name = "href") %>%
        stringr::str_extract(pattern = "\\d{8}") %>%
        lubridate::ymd()
      
    } else {
      
      raw_subextract <-
        raw_extract[[i]] %>%
        rvest::html_nodes(css = "li")
      
      # exclude cancelled proposals (formatted struck through)
      is_cancelled <-
        raw_subextract %>%
        rvest::html_node(css = "span") %>%
        rvest::html_attr(name = "class") %>%
        magrittr::equals("txt_barre") %>%
        purrr::map_lgl(isTRUE)
      
      raw_subextract %<>%
        magrittr::extract(!is_cancelled)
      
      if (length(raw_subextract)) {
        
        referendum_dates %<>% tibble::add_row(date = !!date,
                                              level = !!level[i],
                                              municipality = vote_locations[i],
                                              subject =
                                                raw_subextract %>%
                                                rvest::html_text() %>%
                                                stringr::str_squish())
      }
    }
  }
  
  # set `municipality` to NA again if `level` isn't municipal
  referendum_dates %>% dplyr::mutate(municipality = dplyr::if_else(condition = level == "municipal",
                                                                   true = municipality,
                                                                   false = NA_character_))
}

scrape_geneva_referendum_dates_after_2014 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = "https://www.ge.ch/votations/welcome.asp",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure") %>%
    rvest::html_nodes(css = "ul")
  
  is_relevant_year <-
    raw_extract %>%
    as.character() %>%
    stringr::str_extract(pattern = "\\d{8}") %>%
    lubridate::ymd() %>%
    lubridate::year() %>%
    magrittr::is_in(year)
  
  raw_extract %<>%
    magrittr::extract(is_relevant_year) %>%
    rvest::html_nodes(css = "li")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  ## process vote date specific subpages
  for (i in seq_along(raw_extract)) {
    
    href <-
      raw_extract[i] %>%
      rvest::html_nodes(css = "a") %>%
      rvest::html_attr(name = "href")
    
    # skip dates lacking a link to a subpage (supposedly preliminary)
    if (length(href)) {
      
      date <-
        href %>%
        stringr::str_extract(pattern = "\\d{8}") %>%
        lubridate::ymd()
      
      subpage_url <- paste0("https://www.ge.ch", href)
      
      # subpage format has changed from 2018-09-23 onwards
      if (date < "2018-09-23") {
        
        referendum_dates %<>% dplyr::bind_rows(scrape_geneva_referendum_date_between_2014_mid_2018(date = date,
                                                                                                   url = subpage_url))
      } else {
        
        referendum_dates %<>% dplyr::bind_rows(scrape_geneva_referendum_date_after_mid_2018(date = date,
                                                                                            url = subpage_url))
      }
    }
  }
  
  referendum_dates
}

scrape_geneva_referendum_date_between_2014_mid_2018 <- function(date,
                                                                url) {
  raw_extract <-
    xml2::read_html(x = url,
                    # subpage format has changed from 2018-09-23 onwards
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure")
  
  vote_locations <-
    raw_extract %>%
    rvest::html_nodes(css = "h4") %>%
    rvest::html_text() %>%
    stringr::str_trim() %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$")
  
  raw_extract %<>% rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (i in seq_along(raw_extract)) {
    
    if (!is.na(level[i])) {
      
      raw_subextract <-
        raw_extract[i] %>%
        rvest::html_nodes(css = "li")
      
      # exclude cancelled proposals (formatted struck through)
      is_cancelled <-
        raw_subextract %>%
        rvest::html_node(css = "span") %>%
        rvest::html_attr(name = "class") %>%
        magrittr::equals("txt_barre") %>%
        purrr::map_lgl(isTRUE)
      
      raw_subextract %<>%
        magrittr::extract(!is_cancelled)
      
      if (length(raw_subextract)) {
        
        referendum_dates %<>% tibble::add_row(date = !!date,
                                              level = !!level[i],
                                              municipality =
                                                dplyr::if_else(condition = level == "municipal",
                                                               true = vote_locations[i],
                                                               false = NA_character_),
                                              subject =
                                                raw_subextract %>%
                                                rvest::html_text() %>%
                                                stringr::str_squish())
      }
    }
  }
  
  referendum_dates
}

scrape_geneva_referendum_date_after_mid_2018 <- function(date,
                                                         url) {
  raw_extract <- xml2::read_html(x = url,
                                 # subpage format has changed from 2018-09-23 onwards
                                 encoding = "UTF-8")
  
  # get all "objet_*" selectors
  objet_selectors <-
    raw_extract %>%
    rvest::html_nodes(css = ".container") %>%
    rvest::html_nodes(css = "*") %>%
    rvest::html_attr("id") %>%
    unique() %>%
    magrittr::extract(stringr::str_detect(string = .,
                                          pattern = "^objet_")
                      & !is.na(.)) %>%
    paste0("#", .)
  
  vote_locations <-
    raw_extract %>%
    rvest::html_nodes(css = ".container") %>%
    rvest::html_nodes(css = "h2") %>%
    rvest::html_text() %>%
    magrittr::extract(!stringr::str_detect(string = .,
                                           pattern = "(?i)(documentation|(f\u00e9d\u00e9ra|cantona)(l|ux))")) %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$") %>%
    stringr::str_to_title() %>%
    # undo uppercasing of "middle words" (like the "La" in "Aire-La-Ville")
    gsub(pattern = "(-.+?-)",
         replacement = "\\L\\1",
         perl = TRUE)
  
  if (length(vote_locations) == 0L) vote_locations <- NA_character_
  
  subjects <-
    raw_extract %>%
    rvest::html_nodes(css = paste0(objet_selectors, collapse = ","))
  
  subjects <-
    subjects %>%
    rvest::html_nodes(css = "strong") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    paste(subjects %>%
            rvest::html_nodes(css = "small") %>%
            rvest::html_text() %>%
            stringr::str_squish(),
          sep = " \u2013 ")
  
  referendum_dates <- tibble::tibble(date = date,
                                     level =
                                       objet_selectors %>%
                                       stringr::str_extract(pattern = "(?<=^#objet_).+?(?=_)") %>%
                                       stringr::str_replace(pattern = "FED", replacement = "federal") %>%
                                       stringr::str_replace(pattern = "CAN", replacement = "cantonal") %>%
                                       stringr::str_replace(pattern = "COM", replacement = "municipal"),
                                     municipality = vote_locations,
                                     subject = subjects)
  
  referendum_dates
}

get_geneva_election_dates <- function() {
  
  raw_extract <-
    xml2::read_html(x = "https://www.ge.ch/elections/",
                    encoding = "UTF-8") %>%
    rvest::html_nodes(css = ".liste-lien") %>%
    rvest::html_nodes(css = "li") %>%
    rvest::html_nodes(css = "a") %>%
    # remove erroneous 2nd link @ 1993-10-17 (only visible in source)
    magrittr::extract(-72L)
  
  election_dates <-
    tibble::tibble(date =
                     raw_extract %>%
                     rvest::html_attr(name = "href") %>%
                     stringr::str_extract(pattern = "\\d{8}") %>%
                     lubridate::ymd(),
                   subject_summary =
                     raw_extract %>%
                     rvest::html_text() %>%
                     stringr::str_squish(),
                   is_federal =
                     stringr::str_detect(string = subject_summary,
                                         pattern = "(?i)(Conseil\\s+(des\\s+.tats|National)|f(\u00e9|e)d(\u00e9|e)rale)"),
                   is_cantonal =
                     !is_federal &
                     stringr::str_detect(string = subject_summary,
                                         pattern = paste0("(?i)(",
                                                          "Grand\\s+Conseil|Conseil(ler)?\\s+d.?.tat|Cour\\s+(des?\\s+comptes|d.?appel)",
                                                          "|^Elections\\s+judiciaires$",
                                                          "|Pouvoir\\s+Judiciaire",
                                                          "|Assembl(\u00e9|e)e\\s+constituante",
                                                          ")")),
                   is_municipal =
                     (!is_federal & !is_cantonal),
                   link =
                     raw_extract %>%
                     rvest::html_attr(name = "href") %>%
                     paste0(ifelse(test = stringr::str_detect(string = .,
                                                              pattern = "^https?://"),
                                   yes = "",
                                   no = "https://www.ge.ch/elections/"), .)) %>%
    dplyr::arrange(date)
  
  if (election_dates %>%
      dplyr::select(is_federal, is_cantonal, is_municipal) %>%
      rowSums() %>%
      magrittr::is_greater_than(1L) %>%
      any() %>%
      magrittr::not())
  {
    election_dates %<>% dplyr::transmute(date,
                                         level = dplyr::case_when(is_federal ~ "federal",
                                                                  is_cantonal ~ "cantonal",
                                                                  is_municipal ~ "municipal"),
                                         subject_summary,
                                         link)
    
  } else {
    rlang::abort("Elections on multiple levels at the same date detected! Please update the code of `get_geneva_election_dates()` to support this properly.")
  }
  
  election_dates
}

get_geneva_municipal_election_dates <- function() {
  
  genevan_municipalities <- municipalities(canton = "Geneva")
  
  election_dates <-
    get_geneva_election_dates() %>%
    dplyr::filter(level == "municipal") %>%
    dplyr::select(-level) %>%
    dplyr::mutate(municipality = NA_character_) %>%
    # fix URLs
    dplyr::mutate(link = stringr::str_remove(string = link,
                                             pattern = "res_cn_home.asp$"))
  
  additional_rows <- election_dates[0L, ]
  
  # determine municipalities ...
  for (i in seq_len(nrow(election_dates))) {
    
    # initialize potentially to replace subject summary
    new_subject_summaries <- character(0L)
    
    # ...  where already mentioned in subject summary ...
    matched_municipality <- genevan_municipalities[stringr::str_detect(string = election_dates$subject_summary[i],
                                                                       pattern = paste0("\\b", genevan_municipalities, "\\b"))]
    
    # ... or otherwise by inspecting the relevant subpages
    if (length(matched_municipality) == 0L) {
      
      matched_municipalities <- character()
      
      raw_extract <- xml2::read_html(x = election_dates$link[i],
                                     encoding = "UTF-8")
      
      # handle "normal" subpage layout
      try_to_match <-
        raw_extract %>%
        rvest::html_nodes(css = ".liste-lien") %>%
        rvest::html_nodes(css = "li") %>%
        rvest::html_nodes(css = "a")
      
      # handle different subpage layout (e.g. 2007-06-03)
      if (length(try_to_match) == 0L) {
        
        try_to_match <-
          raw_extract %>%
          rvest::html_nodes(css = ".content") %>%
          rvest::html_nodes(css = "h2")
      }
      
      try_to_match %<>%
        rvest::html_text() %>%
        stringr::str_squish()
      
      if (length(try_to_match)) {
        
        for (j in seq_along(try_to_match)) {
          
          matched_municipalities %<>%
            c(genevan_municipalities[stringr::str_detect(string = try_to_match[j],
                                                         pattern = paste0("\\b", genevan_municipalities, "\\b"))])
        }
      }
      
      if (length(matched_municipalities) == 0L) {
        
        # handle yet another subpage layout (-> one level deeper)
        subpage_links <-
          raw_extract %>%
          rvest::html_nodes(css = ".liste-lien") %>%
          rvest::html_nodes(css = "li") %>%
          rvest::html_nodes(css = "a") %>%
          rvest::html_attr(name = "href") %>%
          purrr::map_chr(~ paste0(election_dates$link[i], .x))
        
        for (link in subpage_links) {
          
          raw_extract <- xml2::read_html(x = link,
                                         encoding = "UTF-8")
          
          new_subject_summary <-
            raw_extract %>%
            rvest::html_nodes(css = ".content") %>%
            rvest::html_nodes(css = "h2") %>%
            rvest::html_text() %>%
            stringr::str_squish()
          
          if (length(new_subject_summary) != 1L) {
            
            rlang::abort("Unexpected scraping result! Please update the code of `get_geneva_municipal_election_dates()`.")
            
          } else {
            
            new_subject_summaries %<>% c(new_subject_summary)
          }
          
          try_to_match <-
            raw_extract %>%
            rvest::html_nodes(css = ".liste-lien") %>%
            rvest::html_nodes(css = "li") %>%
            rvest::html_nodes(css = "a") %>%
            rvest::html_text() %>%
            stringr::str_squish()
          
          if (length(try_to_match)) {
            
            for (j in seq_along(try_to_match))
            {
              matched_municipalities %<>% c(genevan_municipalities[stringr::str_detect(string = try_to_match[j],
                                                                                       pattern = paste0("\\b", genevan_municipalities, "\\b"))])
            }
          }
        }
        
        # assign 1st matched municipalitiy to original row ...
        matched_municipality <- matched_municipalities[1L]
        
        # ... and set the rest aside to append later on
        additional_rows %<>% tibble::add_row(date = election_dates$date[i],
                                             subject_summary =
                                               sapply(X = new_subject_summaries,
                                                      FUN = rep,
                                                      times = length(matched_municipalities) / length(new_subject_summaries),
                                                      simplify = FALSE) %>%
                                               unlist() %>%
                                               magrittr::extract(-1L),
                                             link = election_dates$link[i],
                                             municipality = matched_municipalities[-1L])
        
      } else {
        
        # assign 1st matched municipality to original row ...
        matched_municipality <- matched_municipalities[1L]
        
        # ... and set the rest aside to append later on
        additional_rows %<>% tibble::add_row(date = election_dates$date[i],
                                             subject_summary = election_dates$subject_summary[i],
                                             link = election_dates$link[i],
                                             municipality = matched_municipalities[2L:length(matched_municipalities)])
      }
    } else if (length(matched_municipality) > 1L) {
      
      rlang::abort("Multiple municipalities detected in `subject_summary`! Please update the code of `get_geneva_municipal_election_dates()`.")
    }
    
    election_dates$municipality[i] <- matched_municipality
    if (length(new_subject_summaries)) election_dates$subject_summary[i] <- new_subject_summaries[1L]
  }
  
  # append remaining municipalities
  election_dates %<>% dplyr::bind_rows(additional_rows)
  
  # remove duplicates (Corsier was sometimes archived later and thus appears twice in such cases)
  duplicate_indices <- integer()
  
  for (i in stringr::str_which(string = election_dates$link,
                               pattern = "^https://www\\.ge\\.ch/elections/\\d+?/.+$")) {
    
    if (election_dates$link[-i] %>%
        stringr::str_detect(pattern = paste0(stringr::str_extract(string = election_dates$link[i],
                                                                  pattern = "^https://www\\.ge\\.ch/elections/\\d+"),
                                             "/?$")) %>%
        any()) {
      
      duplicate_indices %<>% c(i)
    }
  }
  
  election_dates %>%
    dplyr::filter(!(dplyr::row_number(link) %in% duplicate_indices)) %>%
    # sort columns
    dplyr::transmute(date,
                     municipality,
                     subject = subject_summary) %>%
    # sort rows
    dplyr::arrange(date, municipality)
}

get_zurich_referendum_dates <- function(exclude_counterproposals = FALSE) {
  
  referendum_dates <-
    jsonlite::fromJSON(txt = "https://www.web.statistik.zh.ch/cms_abstimmungsarchiv/includes/ajax_get_vorlagen.php") %$%
    aaData %>%
    magrittr::set_colnames(ncol(.) %>% seq_len() %>% paste0("V", .)) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(id = as.integer(V1),
                     date = lubridate::dmy(V2),
                     level =
                       V3 %>%
                       stringr::str_extract(pattern = "(?<=title=\").+?(?=\")") %>%
                       stringr::str_replace_all(c("Eidgen\u00f6ssische Abstimmung" = "federal",
                                                  "Kantonale Abstimmung" = "cantonal")),
                     subject =
                       .$V4 %>%
                       paste0(collapse = "\n") %>%
                       xml2::read_html() %>%
                       rvest::html_text() %>%
                       stringr::str_split(pattern = "\n") %>%
                       unlist() %>%
                       stringr::str_squish(),
                     type = V5,
                     turnout =
                       V6 %>%
                       stringr::str_extract(pattern = "\\d+(\\.\\d+)?") %>%
                       as.numeric() %>%
                       magrittr::divide_by(100L),
                     yes_vote_share =
                       V7 %>%
                       stringr::str_extract(pattern = "\\d+(\\.\\d+)?") %>%
                       as.numeric() %>%
                       magrittr::divide_by(100L)) %>%
    dplyr::arrange(date, level, type)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    referendum_dates %<>% dplyr::filter(!stringr::str_detect(string = type,
                                                             pattern = "(^|:\\s+)(Gegenvorschlag|Stichfrage)"))
  }
  
  referendum_dates
}

get_zurich_municipal_vote_dates <- function(municipalities = NULL,
                                            exclude_counterproposals = FALSE) {
  
  valid_municipalities <- c("Bertschikon",
                            "Boppelsen",
                            "Bubikon",
                            "B\u00fclach",
                            "Fehraltorf",
                            "Kleinandelfingen",
                            "M\u00e4nnedorf",
                            "Maur",
                            "Mettmenstetten",
                            "Schlieren",
                            "Thalwil",
                            "Wiesendangen",
                            "Winterthur",
                            "Z\u00fcrich")
  
  if (is.null(municipalities)) municipalities <- valid_municipalities
  
  # check argument
  test_subset <- checkmate::check_subset(x = municipalities,
                                         choices = valid_municipalities)
  
  if (!isTRUE(test_subset)) {
    
    rlang::abort("Invalid argument provided: `municipalities`\n", test_subset)
  }
  
  unimplemented_municipalities <- c("Bertschikon",
                                    "Bubikon",
                                    "Fehraltorf",
                                    "Kleinandelfingen",
                                    "Wiesendangen")
  
  partially_implemented_municipalities <- c("B\u00fclach",
                                            "Maur")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (municipality in municipalities) {
    
    if (municipality %in% unimplemented_municipalities) {
      
      rlang::warn("Scraping vote dates from the municipality ", municipality,
                  " hasn't been implemented yet (or isn't even possible to implement). Therefore its municipal vote dates won't be included.")
      
    } else if (municipality %in% partially_implemented_municipalities) {
      
      rlang::warn("Scraping vote dates from the municipality ", municipality, " is only partially implemented so far and the structure of the returned data ",
                  "differs from the other municipalities. Therefore its municipal vote dates won't be included.")
    } else {
      
      # print a warning about missing election dates from Zurich
      if (municipality == "Z\u00fcrich") {
        
        rlang::warn("For the municipality ", municipality, " only referendum dates can be scraped. The municipal elections dates have to be gathered by hand.")
      }
      
      current_dates <- switch(EXPR = municipality,
                              "Boppelsen" = get_zurich_municipal_dates_boppelsen(),
                              "M\u00e4nnedorf" = get_zurich_municipal_dates_maennedorf(),
                              "Mettmenstetten" = get_zurich_municipal_dates_mettmenstetten(),
                              "Schlieren" = get_zurich_municipal_dates_schlieren(),
                              "Thalwil" = get_zurich_municipal_dates_thalwil(),
                              "Winterthur" = get_zurich_municipal_dates_winterthur(),
                              "Z\u00fcrich" = get_zurich_municipal_referendum_dates_zuerich(exclude_counterproposals = exclude_counterproposals))
      
      vote_dates %<>% dplyr::full_join(y = current_dates,
                                       by = colnames(current_dates))
    }
  }
  
  vote_dates %>% dplyr::arrange(date, municipality, is_election)
}

election_regex <- "(?i)(^Pfarrer\\s|\\b(Erneuerungs?|Ersatz|Pfarr)?wahl(en|gang|g\u00e4nge)?\\b)"

get_zurich_municipal_dates_generic <- function(municipality,
                                               base_url,
                                               start_date = "2000-01-01",
                                               municipal_types = c("bezirk", "kirchlich", "kommunal", "kreis", "verband")) {
  start_date %<>% lubridate::as_date()
  
  base_url %<>% paste0("?date_f=",
                       start_date %>% lubridate::day() %>% stringr::str_pad(width = 2L, side = "left", pad = "0"), ".",
                       start_date %>% lubridate::month() %>% stringr::str_pad(width = 2L, side = "left", pad = "0"), ".",
                       lubridate::year(start_date))
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (municipal_type in municipal_types) {
    
    raw_extract <-
      xml2::read_html(x = paste0(base_url, "&niveau=", municipal_type),
                      encoding = "windows-1252") %>%
      rvest::html_nodes(css = "table") %>%
      dplyr::last() %>%
      rvest::html_table() %>%
      tibble::as_tibble()
    
    if (all(c("Termin", "Titel der Vorlage") %in% colnames(raw_extract))) {
      
      vote_dates <-
        raw_extract %>%
        dplyr::transmute(date = lubridate::dmy(Termin),
                         municipality = !!municipality,
                         is_election = stringr::str_detect(string = `Titel der Vorlage`,
                                                           pattern = election_regex),
                         subject = `Titel der Vorlage`) %>%
        dplyr::bind_rows(vote_dates)
    }
  }
  
  if (nrow(vote_dates) == 0L) {
    
    rlang::abort("No <table> node of the expected structure was returned. You might have to update the `get_zurich_municipal_dates_generic()` function.")
  }
  
  vote_dates %>% dplyr::arrange(date, municipality, is_election)
}

get_zurich_municipal_dates_boppelsen <- function() {
  
  raw_extract <-
    xml2::read_html(x = "http://www.boppelsen.ch/gemeinde/politik/wahlen/archiv/default.htm",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = ".portletDocumentListWrapper")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  summary_texts <-
    raw_extract %>%
    rvest::html_nodes(css = "h3") %>%
    rvest::html_text()
  
  dates <-
    summary_texts %>%
    stringr::str_extract(pattern = "\\d+\\.\\s+\\S+\\s+\\d{4}(\\s+)?$") %>%
    lubridate::dmy()
  
  is_election_date <- stringr::str_detect(string = summary_texts,
                                          pattern = "(?i)wahl")
  
  raw_extract %<>% rvest::html_nodes(css = "ul")
  
  for (i in seq_along(dates)) {
    
    subject_part <-
      raw_extract[[i]] %>%
      rvest::html_nodes(css = "li") %>%
      rvest::html_nodes(css = "a") %>%
      rvest::html_attr(name = "title") %>%
      # filter non-municipal subjects
      magrittr::extract(!stringr::str_detect(string = .,
                                             pattern = "(?i)((national|st(\u00e4|ae)nde|kantons|regierungs)rat|eidge?n\u00f6ssis?che|kantonale)"))
    
    if (length(subject_part)) {
      
      vote_dates %<>% tibble::add_row(date = dates[i],
                                      municipality = "Boppelsen",
                                      is_election =
                                        is_election_date[i] &
                                        !stringr::str_detect(string = subject_part,
                                                             pattern = "(?i)(abstimmung|initiative|kredit|referendum|revision)"),
                                      subject = paste0(summary_texts[i], ": ", subject_part))
    }
  }
  
  vote_dates %>% dplyr::arrange(date, municipality, is_election)
}

get_zurich_municipal_dates_buelach <- function() {
  
  raw_extract <-
    xml2::read_html(x = "https://www.buelach.ch/themen/politik_verwaltung/wahlen_und_abstimmungen/wahlen_und_abstimmungen_resultate/",
                    encoding = "UTF-8") %>%
    rvest::html_nodes(css = ".element") %>%
    rvest::html_nodes(css = ".list") %>%
    dplyr::first() %>%
    rvest::html_nodes(css = "ul") %>%
    rvest::html_nodes(css = "li")
  
  tibble::tibble(date =
                   raw_extract %>%
                   rvest::html_nodes(css = ".date") %>%
                   rvest::html_text() %>%
                   lubridate::dmy(),
                 municipality = "B\u00fclach",
                 subject_summary =
                   raw_extract %>%
                   rvest::html_nodes(css = ".title") %>%
                   rvest::html_text(),
                 is_election_date = stringr::str_detect(string = subject_summary,
                                                        pattern = "(?i)wahl"),
                 link =
                   raw_extract %>%
                   rvest::html_nodes("a") %>%
                   rvest::html_attr(name = "href") %>%
                   paste0("https://www.buelach.ch/", .)) %>%
    dplyr::transmute(date, municipality, is_election_date, subject_summary, link) %>%
    dplyr::arrange(date, municipality, is_election_date)
}

get_zurich_municipal_dates_maennedorf <- function() {
  
  get_zurich_municipal_dates_generic(municipality = "M\u00e4nnedorf",
                                     base_url = "http://www.maennedorf.ch/de/politik/abstimmungsresultate/archivsuche/welcome.php")
}

get_zurich_municipal_dates_maur <- function() {
  
  raw_extract <-
    httr::POST(url = "http://www.maur.ch/xml_1/internet/de/file/modul/news/archiv.cfm?config=278ED4AB-5056-8276-9CEC654BDC655693&did=1&lid=1&lg=DE&userLG=DE",
               httr::user_agent(agent = "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"),
               httr::content_type(type = "application/x-www-form-urlencoded"),
               # `rubrik = 38` stands for the category "Wahlen / Abstimmungen"
               body = list(searchtype = "rub",
                           year = 0L,
                           month = 0L,
                           rubrik = 38L),
               encode = "form") %>%
    xml2::read_html(encoding = "UTF-8")
  
  vote_dates <-
    tibble::tibble(date =
                     raw_extract %>%
                     rvest::html_nodes(css = ".newsarchiv-date") %>%
                     rvest::html_text() %>%
                     lubridate::dmy(),
                   municipality = "Maur",
                   subject_summary =
                     raw_extract %>%
                     rvest::html_nodes(css = ".newsarchiv-title") %>%
                     rvest::html_text(),
                   is_election_date = stringr::str_detect(string = subject_summary,
                                                          pattern = "(?i)wahl"),
                   link =
                     raw_extract %>%
                     rvest::html_nodes(css = ".newsarchiv-title") %>%
                     rvest::html_nodes(css = "a") %>%
                     rvest::html_attr(name = "href") %>%
                     paste0("http://www.maur.ch/xml_1/internet/de/file/modul/news/", .)) %>%
    dplyr::transmute(date, municipality, is_election_date, subject_summary, link) %>%
    # filter some "false positives"
    dplyr::filter(!stringr::str_detect(string = subject_summary,
                                       pattern = "^(?i)(Formular\\s|Loorenprojekt:\\s)")) %>%
    # and sort
    dplyr::arrange(date, municipality, is_election_date)
  
  vote_dates
}

get_zurich_municipal_dates_mettmenstetten <- function() {
  
  get_zurich_municipal_dates_generic(
    municipality = "Mettmenstetten",
    base_url = "http://www.mettmenstetten.ch/de/politikverwaltung/abstimmungenundwahlen/abstimmungsresultate/archivsuche/welcome.php"
  )
}

get_zurich_municipal_dates_schlieren <- function() {
  
  get_zurich_municipal_dates_generic(municipality = "Schlieren",
                                     base_url = "http://www.schlieren.ch/de/politikverwaltung/politik/abstimmungsresultate/archivsuche/welcome.php")
}

get_zurich_municipal_dates_thalwil <- function() {
  
  get_zurich_municipal_dates_generic(municipality = "Thalwil",
                                     base_url = "http://www.thalwil.ch/de/polver/politik/abstimmungsresultate/politrechtevorlagen/welcome.php")
}

get_zurich_municipal_dates_winterthur <- function() {
  
  raw_extract <-
    xml2::read_html(x = "http://wahlen.winterthur.ch/archiv/vote-action/archive/vote-controller/ElectionDay/vote-year/9999/") %>%
    rvest::html_nodes(css = ".electionday-list") %>%
    rvest::html_nodes(css = ".row")
  
  vote_dates <- tibble::tibble(date = lubridate::as_date(integer()),
                               municipality = character(),
                               is_election = logical(),
                               subject = character())
  
  for (i in seq_along(raw_extract)) {
    
    if (raw_extract[[i]] %>%
        rvest::html_nodes(css = ".col-8") %>%
        rvest::html_text() %>%
        stringr::str_squish() %>%
        magrittr::equals("Es sind noch keine Wahlen/Abstimmungen vorhanden") %>%
        magrittr::not()) {
      
      vote_dates %<>% tibble::add_row(date =
                                        raw_extract[[i]] %>%
                                        rvest::html_nodes(css = ".col-4") %>%
                                        rvest::html_text() %>%
                                        stringr::str_extract(pattern = "\\d+\\.\\d+\\.\\d{4}") %>%
                                        lubridate::dmy(),
                                      municipality = "Winterthur",
                                      subject =
                                        raw_extract[[i]] %>%
                                        rvest::html_nodes(css = ".col-8") %>%
                                        rvest::html_nodes(css = "ul") %>%
                                        rvest::html_nodes(css = "li") %>%
                                        rvest::html_text() %>%
                                        stringr::str_squish())
    }
  }
  
  vote_dates %>%
    dplyr::mutate(is_election = stringr::str_detect(string = subject,
                                                    pattern = election_regex)) %>%
    dplyr::arrange(date, municipality, is_election)
}

get_zurich_municipal_referendum_dates_zuerich <- function(exclude_counterproposals = FALSE) {
  
  referendum_dates <-
    readr::read_csv(file = paste0("https://data.stadt-zuerich.ch/dataset/politik_abstimmungen_seit_1933/resource/3b5a8ed9-0765-4d59-95a1-e87aa98350e3/",
                                  "download/abstimmungen_seit1933.csv"),
                    locale = readr::locale(encoding = "UTF-8",
                                           decimal_mark = "."),
                    col_types = "Dicciciciiidddcc") %>%
    dplyr::filter(Name_Politische_Ebene == "Stadt Z\u00fcrich") %>%
    dplyr::group_by(date = Abstimmungs_Datum,
                    municipality = "Z\u00fcrich",
                    is_election = FALSE,
                    subject = Abstimmungs_Text) %>%
    dplyr::summarise() %>%
    dplyr::arrange(date, municipality) %>%
    # manual corrections
    ## exclude duplicate entries
    dplyr::filter(
      ### @ 1996-06-09
      !((date == "1996-06-09"
         & subject == "A Wohnbauaktion (Rahmenkredit je 10 Mio. Franken) \nB Wohnbauaktion (Rahmenkredit je 20 Mio. Franken) \n Wohnbauaktion (Stichfrage)")
        ### @ 1981-01-25
        | (date == "1981-01-25"
           & subject == "Gegenvorschlag des Stadtrates zur Volksinitiative \u00fcber die Errichtung eines Gesundheitszentrums im Kreis 9"))
    )
  
  if (exclude_counterproposals) {
    
    referendum_dates %<>% dplyr::filter(!stringr::str_detect(string = subject,
                                                             pattern = "(?i)(^[bc][\\s\\.:)]|stichfrage)"))
  }
  
  referendum_dates
}
