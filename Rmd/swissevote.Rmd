---
editor_options:
  chunk_output_type: console
---

# NOTES

## Metadata about raw Geneva data

The Genevan vote register data is often split among several files per ballot date and oddly named. Thus we include the relevant metadata about it directly in
this package. Below is the code to generate the internal data from the CSV file (which is only included in the source repository but not the package).

```{r, purl = FALSE}
# mapping between filenames and ballot dates/types/etc.
metadata_geneva_raw_datasets <- readr::read_csv(file = "data-raw/metadata_geneva_raw_datasets.csv",
                                                col_types = "Dcllllicc")

# mapping between two-digit municipality and district codes and their respective names
metadata_geneva_municipalities_districts <-
  readr::read_csv(file = "data-raw/metadata_geneva_municipalities_districts.csv",
                  col_types = "Diicc") %T>%
  assertr::assert_rows(row_reduction_fn = assertr::col_concat,
                       predicate = assertr::is_uniq,
                       municipality_code_2_digits,
                       district_code)

usethis::use_data(metadata_geneva_raw_datasets,
                  metadata_geneva_municipalities_districts,
                  internal = TRUE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```

### Spelling of municipalities

There is one municipality present in the raw data, _La Grande Béroche_, which has officially changed its spelling. It was created by the merger of four
municipalities on 2018-01-01 and it was initially foreseen that it would be written _La Grande-Béroche_. But the hypen
[was dropped effective 2018-04-01](https://archive.is/x9ixU). A translation of the relevant info:

> The Federal Office of Topography swisstopo, the official body that decides on the spelling of the names of Swiss municipalities, had announced, when the new
> municipality of _La Grande Béroche_ was created, that its name would include a hyphen. However, the merger agreement did not include a hyphen in the name of
> La Grande Béroche. The authorities of La Grande Béroche, with the support of the municipal authorities, initiated an approval procedure with the competent
> federal authorities and obtained their approval. On 9 March, swisstopo confirmed that the spelling of the name of the municipality of La Grande Béroche would
> be officially corrected with effect from 1 April 2018 and would be written without a hyphen.

We treat this municipality as if its name had always been written without a hyphen: _La Grande Béroche_

# INTERNAL

## Package load/unload

```{r}
.onUnload <- function (libpath) {
  
  pkgpins::deregister(pkg = pkg)
}

.onLoad <- function(libname, pkgname) {
  
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption("swissevote.global_cache_lifespan",
                                     default = "30 days"))
  
  # set local path to Google Drive folder dependent on username
  options(swissevote.path_raw_data = switch(EXPR = Sys.info()[["user"]],
                                            "salim" = "~/Arbeit/ZDA/Google Drive/edc-projekt/iVoting_dataset/Datenquellen/",
                                            getOption("swissevote.path_raw_data")))
  
  
  
  if (is.null(getOption("swissevote.path_raw_data")) || is.na(getOption("swissevote.path_raw_data"))) {
    
    rlang::warn(message = msg_raw_data_path_unset)
    
  } else {
    
    test_valid_path_raw_data <- checkmate::test_directory(getOption("swissevote.path_raw_data"),
                                                          access = "r")
    
    if (!isTRUE(test_valid_path_raw_data)) {
      
      rlang::warn(glue::glue("The option `swissevote.path_raw_data` is set to: {getOption('swissevote.path_raw_data')}\n",
                             "This is not a valid path (with at least read access). Please correct this in order for this package to work properly."))
    }
  }
}
```

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "aaData",
                                 "Abstimmungs_Datum",
                                 "Abstimmungs_Text",
                                 "agerevolu",
                                 "all_of",
                                 "annee",
                                 "ballot_date",
                                 "ballot_votes_e_voting_electorate",
                                 "ballot_votes_total",
                                 "canton",
                                 "cantonal_elected_power",
                                 "cantonal_election_procedure",
                                 "cec",
                                 "cnat",
                                 "combined_elected_power",
                                 "combined_election_procedure",
                                 "combined_level",
                                 "comments",
                                 "country",
                                 "country_canton_code",
                                 "datvot",
                                 "district",
                                 "district_code",
                                 "dnais",
                                 "dnaisaa",
                                 "election_level",
                                 "ends_with",
                                 "e_votes",
                                 "e_voting_electorate",
                                 "federal_elected_power",
                                 "federal_election_procedure",
                                 "filename",
                                 "group",
                                 "InitialCode",
                                 "is_cantonal",
                                 "is_cross_vote_aggregated",
                                 "is_election",
                                 "is_election_date",
                                 "is_entire_group_in_all_votes",
                                 "is_e_voting_available",
                                 "is_federal",
                                 "is_foreigner",
                                 "is_matched_group",
                                 "is_municipal",
                                 "is_preregistration_required",
                                 "is_swiss_living_abroad",
                                 "is_wassenaar_corrected",
                                 "level",
                                 "limited_to_cantons",
                                 "link",
                                 "matched_group_notes",
                                 "matches",
                                 "municipal_elected_power",
                                 "municipal_election_procedure",
                                 "municipality",
                                 "municipality_code_2_digits",
                                 "MutationDate",
                                 "MutationNumber",
                                 "n",
                                 "name",
                                 "Name_Politische_Ebene",
                                 "norefnet",
                                 "notes",
                                 "nr_of_cantonal_referendums",
                                 "nr_of_federal_referendums",
                                 "nr_of_municipal_referendums",
                                 "postal_votes_e_voting_electorate",
                                 "postal_votes_total",
                                 "proposal_nrs",
                                 "qualcan",
                                 "qualcom",
                                 "qualfed",
                                 "referendum_level",
                                 "sexe",
                                 "starts_with",
                                 "subject",
                                 "subject_summary",
                                 "starts_with",
                                 "Termin",
                                 "TerminalCode",
                                 "Titel der Vorlage",
                                 "total_electorate",
                                 "type",
                                 "typelec",
                                 "typvot",
                                 "V1",
                                 "V2",
                                 "V3",
                                 "V5",
                                 "V6",
                                 "V7",
                                 "value",
                                 "void_since",
                                 "votarr",
                                 "votcom",
                                 "votcorr",
                                 "votdup",
                                 "vote_count_e_voting_electorate",
                                 "vote_count_total",
                                 "xnoref"))
```

## Constants

```{r}
pkg <- utils::packageName()
```

### Regular expressions

Define the regular expression to detect indirect counterproposals and tie-breaker questions as constant so it can be easily reused

```{r}
regex_counterproposal_fr <- "(?i)(co?n?tre-?projet(?!\\s(direct|relatif))|question\\ssubsidiaire)"
```

### E-voting cantons

```{r}
e_voting_cantons <- tibble::tribble(
  
         ~canton, ~canton_short,
       "Argovia",          "AG",
    "Basel-City",          "BS",
          "Bern",          "BE",
      "Fribourg",          "FR",
        "Geneva",          "GE",
        "Glarus",          "GL",
       "Grisons",          "GR",
       "Lucerne",          "LU",
     "Neuchatel",          "NE",
  "Schaffhausen",          "SH",
     "Solothurn",          "SO",
    "St. Gallen",          "SG",
       "Thurgau",          "TG",
          "Vaud",          "VD",
        "Zurich",          "ZH"
  )
```

### Messages

```{r}
msg_raw_data_path_unset <- paste0("Please set the proper path to the cantonal raw data files in the option `swissevote.path_raw_data`.\n",
                                  "To do so, run: `options(swissevote.path_raw_data = 'PATH/TO/Datenquellen/')`")
```

## Assemble raw data path

```{r}
path_raw_data <- function(...,
                          ext = "") {
  
  path_raw_data <- getOption("swissevote.path_raw_data")
  
  if (is.null(path_raw_data)) {
    rlang::abort(message = msg_raw_data_path_unset)
  }
  
  if (!checkmate::test_directory(path_raw_data,
                                 access = "r")) {
    rlang::abort(paste0("The path to the cantonal raw data files is either not valid or not readable.\n",
                        msg_raw_data_path_unset))
  }
  
  path_raw_data %>%
  fs::path(...,
           ext = ext) %>%
    fs::path_abs()
}
```

## Determine filetype of raw data file

```{r}
filetype_data_raw <- function(file_path,
                              file_type_precedence = c("csv", "zip", "xlsx")) {
  
  filename <- fs::path_file(file_path)
  dir <- fs::path_dir(file_path)
  
  dir %>%
    fs::dir_ls(type = "file",
               glob = fs::path(dir, paste0(filename, "*"))) %>%
    fs::path_ext() %>%
    match(table = file_type_precedence) %>%
    sort() %>%
    dplyr::first() %>%
    {file_type_precedence[.]}
}
```

## Get municipalities that occured in the data so far

TODO: Replace hardcoded municipalities by a generic solution.

```{r}
municipalities <- function(canton = c("Geneva", "Neuchatel", "Zurich")) {
  
  switch(EXPR = rlang::arg_match(canton),
         "Geneva" = c("Ani\u00e8res",
                      "Cologny",
                      "Carouge",
                      "Meyrin",
                      "Vandoeuvres",
                      "Collonge-Bellerive",
                      "Onex",
                      "Versoix",
                      "Bernex",
                      "Ch\u00eane-Bourg",
                      "Grand-Saconnex",
                      "Lancy",
                      "Th\u00f4nex",
                      "Vernier",
                      "Perly-Certoux",
                      "Plan-les-Ouates",
                      "Ch\u00eane-Bougeries",
                      "Avusy",
                      "Aire-la-Ville",
                      "Troinex",
                      "Avully",
                      "Bardonnex",
                      "Bellevue",
                      "Cartigny",
                      "C\u00e9ligny",
                      "Chancy",
                      "Choulex",
                      "Collex-Bossy",
                      "Confignon",
                      "Corsier",
                      "Dardagny",
                      "Gen\u00e8ve",
                      "Genthod",
                      "Gy",
                      "Hermance",
                      "Jussy",
                      "Laconnex",
                      "Meinier",
                      "Pregny-Chamb\u00e9sy",
                      "Presinge",
                      "Puplinge",
                      "Russin",
                      "Satigny",
                      "Soral",
                      "Veyrier"),
         rlang::abort("Not implemented yet."))
}
```

## Convert codes

TODO: Get rid of the `*_code_*` vars altogether and transform the fns below to convert strings/factors

### Determine combination of three-code variables (`combined_election_procedure`)

```{r}
#' Determine combination of three-code variables (`combined_election_procedure`)
#'
#' @param ... Up to three individual codes as integers. `pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return An integer scalar.
determine_3_code_combo <- function(...) {
  
  input_codes <-
    rlang::list2(...) %>%
    purrr::flatten_dbl() %>%
    as.integer()
  
  combined_code <- NA_integer_
  
  # show warning if all three codes are NA
  if (all(is.na(input_codes))) {
    
    rlang::warn("`combined_code` couldn't be determined because all codes are `NA`!")
    
  } else {
    
    # define a vector of all codes excluding NAs
    all_codes <- input_codes[!is.na(input_codes)]
    
    # if all codes are the same, just assign the first one
    if (length(unique(all_codes)) == 1L) {
      
      combined_code <- all_codes[1L]
      
      # else combined code must be 3
    } else combined_code <- 3L
  }
  
  combined_code
}
```

### Determine combination of seven-code variables (like `combined_level`)

```{r}
#' Determine combination of seven-code variables (like `combined_level`)
#'
#' @param ... Up to three individual codes as integers. `pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return An integer scalar.
determine_7_code_combo <- function(...) {
  
  input_codes <-
    rlang::list2(...) %>%
    purrr::flatten_dbl() %>%
    as.integer()
  
  combined_code <- NA_integer_
  
  # show warning if all three codes are NA
  if (all(is.na(input_codes))) {
    
    rlang::warn("`combined_code` couldn't be determined because all codes are `NA`!")
    
  } else {
    
    # define a vector of all codes excluding NAs and 0s
    all_codes <- input_codes %>% magrittr::extract(!is.na(.) & !(. == 0L))
    
    # if `all_codes` is empty, return 0
    if (length(all_codes) == 0L) {
      
      combined_code <- 0L
      
      # if all codes are the same, just assign the first one
    } else if (length(unique(all_codes)) == 1L) {
      
      combined_code <- all_codes[1L]
      
      # handle remaining combinations
    } else {
      
      combined_code <- dplyr::case_when(7L %in% all_codes
                                        | all(all_codes > 3L)
                                        | all(c(1L, 6L) %in% all_codes)
                                        | all(c(2L, 5L) %in% all_codes)
                                        | all(c(3L, 4L) %in% all_codes)
                                        | all(c(1L, 2L, 3L) %in% all_codes)
                                        | all(c(1L, 4L, 5L) %in% all_codes) ~ 7L,
                                        all(all_codes %in% c(2L, 3L, 6L)) ~ 6L,
                                        all(all_codes %in% c(1L, 3L, 5L)) ~ 5L,
                                        all(all_codes %in% c(1L, 2L, 4L)) ~ 4L)
    }
  }
  
  combined_code
}
```

### Determine `combined_elected_power`

```{r}
combine_elected_powers <- function(federal_elected_power = NA,
                                   cantonal_elected_power = NA,
                                   municipal_elected_power = NA) {
  
  combined_elected_power <-
    determine_7_code_combo(
      # convert federal_elected_power code to schema of cantonal/municipal_elected_power
      dplyr::if_else(federal_elected_power > 0L,
                     1L,
                     as.integer(federal_elected_power)),
      cantonal_elected_power,
      municipal_elected_power
    )
  
  combined_elected_power
}
```

### Combine group code

```{r}
combine_group <- function(...) {
  
  input_codes <-
    rlang::list2(...) %>%
    purrr::flatten_dbl() %>%
    as.integer()
  
  combined_code <- NA_integer_
  
  # show warning if all three codes are NA
  if (all(is.na(input_codes))) {
    
    rlang::warn("`combined_code` couldn't be determined because all codes are `NA`!")
    
  } else {
    
    # define a vector of all codes excluding NAs and 0s
    all_codes <- input_codes %>% magrittr::extract(!is.na(.) & !(. == 0L))
    
    # if `all_codes` is empty, return 0
    if (length(all_codes) == 0L) {
      
      combined_code <- 0L
      
      # if all codes are the same, just assign the first one
    } else if (length(unique(all_codes)) == 1L) {
      
      combined_code <- all_codes[1L]
      
      # handle remaining combinations
    } else {
      
      combined_code <- dplyr::case_when(6L %in% all_codes
                                        | all(c(2L, 5L) %in% all_codes)
                                        | all(c(3L, 4L) %in% all_codes)
                                        | all(c(4L, 5L) %in% all_codes)
                                        | all(c(1L, 2L, 3L) %in% all_codes) ~ 6L,
                                        all(all_codes %in% c(1L, 3L, 5L)) ~ 5L,
                                        all(all_codes %in% c(1L, 2L, 4L)) ~ 4L)
    }
    
    combined_code
  }
}
```

### Convert `group` code to `group_name`

```{r}
get_group_name <- function(group) {
  
  switch(EXPR = as.character(group),
         "1" = "Swiss citizens living in Switzerland" ,
         "2" = "Swiss citizens living abroad" ,
         "3" = "foreigners" ,
         "4" = "Swiss citizens living in Switzerland & Swiss citizens living abroad" ,
         "5" = "Swiss citizens living in Switzerland & foreigners" ,
         "6" = "Swiss citizens living in Switzerland & Swiss citizens living abroad & foreigners",
         NA_character_)
}
```

### Convert `type` code to `type_name`

```{r}
get_type_name <- function(type) {
  
  switch(EXPR = as.character(type),
         "1" = "referendum" ,
         "2" = "election" ,
         "3" = "both (referendum & election)",
         NA_character_)
}
```

### Convert `*_level` code to name(s)

```{r}
get_level_name <- function(level) {
  
  switch(EXPR = as.character(level),
         "0" = "none",
         "1" = "federal only",
         "2" = "cantonal only",
         "3" = "municipal only",
         "4" = "federal & cantonal",
         "5" = "federal & municipal",
         "6" = "cantonal & municipal",
         "7" = "all three (federal & cantonal & municipal)",
         NA_character_)
}
```

### Convert `federal_elected_power` code to `federal_elected_power_name`

```{r}
get_federal_elected_power_name <- function(federal_elected_power) {
  
  switch(EXPR = as.character(federal_elected_power),
         "0" = "none",
         "1" = "legislature (National Council)" ,
         "2" = "legislature (Council of States)" ,
         "3" = "legislature (National Council & Council of States)",
         NA_character_)
}
```

### Convert `*_elected_power` code to name(s)

This does _not_ apply to `federal_elected_power`!

```{r}
get_elected_power_name <- function(elected_power) {
  
  switch(EXPR = as.character(elected_power),
         "0" = "none",
         "1" = "legislature",
         "2" = "executive",
         "3" = "judiciary",
         "4" = c("legislature", "executive"),
         "5" = c("legislature", "judiciary"),
         "6" = c("executive", "judiciary"),
         "7" = c("legislature", "executive", "judiciary"),
         NA_character_) %>%
    purrr::when(is.na(.) ~ .,
                ~ paste0(collapse = " & "))
}
```

### Convert `*_election_procedure` codes to names

```{r}
get_election_procedure_name <- function(election_procedure) {
  
  switch(EXPR = as.character(election_procedure),
         "0" = "none",
         "1" = "proportional voting" ,
         "2" = "majority voting" ,
         "3" = "proportional voting & majority voting",
         NA_character_)
}
```

# Utilities

## Convert between full canton names and their two-letter abbreviations

```{r}
#' Convert between full canton names and their two-letter abbreviations
#'
#' @param cantons The full names or two-letter abbreviations of the cantons to be converted. A character vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' convert_canton_names(c("ZH", "VD", "AG"))
#' convert_canton_names(c("Zurich", "Vaud", "Argovia"))
#' convert_canton_names(c("ZH", "Vaud", "Argovia"))
convert_canton_names <- function(cantons) {
  
  converted_names <- character()
  
  for (canton_name in checkmate::assert_character(cantons,
                                                  any.missing = FALSE)) {
    
    long_match <- match(x = canton_name,
                        table = e_voting_cantons$canton)
    short_match <- match(x = canton_name,
                         table = e_voting_cantons$canton_short)
    
    if (!is.na(long_match)) {
      
      converted_names %<>% c(e_voting_cantons$canton_short[long_match])
      
    } else if (!is.na(short_match)) {
      
      converted_names %<>% c(e_voting_cantons$canton[short_match])
      
    } else rlang::abort(glue::glue("`{canton_name}` is not a valid e-voting canton."))
  }
  
  converted_names
}
```

# Process vote register data

## List ballot dates for which raw data files are available

```{r}
#' List ballot dates for which raw data files are available
#'
#' @param canton The canton for which to list ballot dates. A character scalar.
#'
#' @return A vector of [dates][base::Date].
#' @export
ballot_dates_raw_data <- function(canton = c("Bern", "Geneva", "Neuchatel")) {
  
  canton_short <- rlang::arg_match(canton) %>% convert_canton_names()
  
  result <-
    getOption("swissevote.path_raw_data") %>%
    fs::path(canton_short) %>%
    fs::dir_ls(type = "file",
               regexp = switch(EXPR = canton_short,
                               GE = paste0("/", pal::fuse_regex(metadata_geneva_raw_datasets$filename), "\\.(csv|zip|xlsx)$"),
                               glue::glue("/{canton_short}_\\d{{4}}-\\d{{2}}-\\d{{2}}\\.(csv|zip|xlsx)$"))) %>%
    stringr::str_extract(pattern = dplyr::if_else(canton_short == "GE",
                                                  "v\\d{6}(_\\d+)?(?=\\.(csv|zip|xlsx)$)",
                                                  "\\d{4}-\\d{2}-\\d{2}(?=\\.(csv|zip|xlsx)$)"))
  
  if (canton_short == "GE") {
    
    result <-
      metadata_geneva_raw_datasets %>%
      dplyr::filter(filename %in% result) %$%
      ballot_date %>%
      unique()
  }
  
  result %>%
    lubridate::as_date() %>%
    sort()
}
```

## Read in raw data files

TODO: Remove custom `.id = ...` as soon as `pkgpins::call_to_name()` arg evaluation issue is resolved.

```{r}
#' Read in raw data files of a specific Swiss canton
#'
#' @param canton The canton of which to read in raw data files.
#' @param ballot_date The ballot date of which to read in raw data files.
#' @param specific_datasets If not `NULL`, only the specified filenames will be processed. A list with ballot dates as keys and character vectors of specific
#'   filenames (without the filetype extension) as values. Setting `specific_datasets` is only sensible in case of `canton = "Geneva"` and thus ignored
#'   otherwise.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")`
#'
#' @return In case of `canton = "Geneva"`, a list with a tibble for each raw data file plus a metadata tibble. Otherwise a single tibble.
#' @export
read_raw_data <- function(canton = c("Bern", "Geneva", "Neuchatel"),
                          ballot_date,
                          specific_datasets = NULL,
                          use_cache = TRUE,
                          cache_lifespan = "7 days") {
  
  canton <- rlang::arg_match(canton)
  
  pkgpins::with_cache(
    .fn = function(canton,
                   ballot_date,
                   specific_datasets) {
      
      switch(EXPR = canton,
             "Bern" = read_raw_data_bern(ballot_date = ballot_date),
             "Geneva" = read_raw_data_geneva(ballot_date = ballot_date,
                                             specific_datasets = specific_datasets),
             "Neuchatel" = read_raw_data_neuchatel(ballot_date = ballot_date))
    },
    canton = canton,
    ballot_date = ballot_date,
    specific_datasets = specific_datasets,
    .use_cache = use_cache,
    .cache_lifespan = cache_lifespan,
    .id = paste0(pkg, "-read_raw_data-", pkgpins:::expr_to_hash(list(canton = canton,
                                                                     ballot_date = ballot_date,
                                                                     specific_datasets = specific_datasets))),
    .pkg = pkg
  )
}
```

### Bern

```{r}
read_raw_data_bern <- function(ballot_date) {
  
  # assemble partial file path
  file_path <- path_raw_data(glue::glue("BE/BE_{ballot_date}"))
  
  # determine file type
  file_type <- filetype_data_raw(file_path = file_path)
  
  # read in data
  if (is.na(file_type)) {
    
    # if file couldn't be found, print a warning and return an empty dataframe
    rlang::warn(glue::glue("File {file_path} neither found in XLSX nor in CSV or ZIP format!"))
    
    data_raw <- tibble::tibble()
    
  } else if (file_type == "xlsx") {
    
    data_raw <- readxl::read_excel(path = fs::path(file_path,
                                                   ext = file_type),
                                   col_names = c("variable", "value"),
                                   col_types = c("text", "numeric"),
                                   skip = 0L)
    
  } else {
    
    data_raw <- readr::read_delim(file = fs::path(file_path,
                                                   ext = file_type),
                                  col_names = c("variable", "value"),
                                  col_types = "cn",
                                  locale = readr::locale(encoding = "UTF-8",
                                                         decimal_mark = "."),
                                  delim = ",",
                                  trim_ws = TRUE,
                                  skip = 0L)
  }
  
  data_raw
}
```

### Geneva

**Remarks:**

- Data might be spread over multiple files if a vote on the municipal level took place on the same date as votes on other levels. Before 2015-06-14, Swiss
  abroad are also located in separate files (with filenames ending in the "virtual" municipality code `_46`). See `swissevote:::metadata_geneva_raw_datasets`
  for specifics. The `read_raw_data_geneva()` function below reads in _all_ of them as long as they're available. The `create_geneva_data()` function is
  designed to do a subsequent cross-vote aggregation.

- There seems to be more than one variable for multiple relevant entities in the Genevese voting register data. Therefore we had to decide which ones of these
  we use for our data processing:

    entity | possible variables | chosen variable | notes
    ------ | ------------------ | --------------- | -----
    `municipality` | `ccom`, `domicom`, `votcom` | **`votcom`** | in the `2016-11-27` data `ccom != votcom` in 27 instances and `domicom != votcom` in one instance; the differences [seem to be larger at earlier ballot dates](https://gitlab.com/c2d-zda/i_voting_dataset/-/issues/16#note_400206372)
    `vote_date` | `date`, `idate` | **`date`** | `idate` is only contained in newer datasets from 2012 onwards;  regarding the `2016-11-27` data, in once instance there's no (semantic) congruence (`date == 19000101` but `idate == 20161130`)
    
- To determine the `group` there's in theory (i.e. according to the Genevan codebook) the variable `typelec` differentiating between _Suisse résident_ (`SR`),
  _Suisse de l'étranger_ (`SE`) and _Etranger résident_ (`ER`). But de facto this variable is either always `NA` (up until 2009 and some later dates, e.g.
  `2011-05-15` and `2011-11-27`), only shows two values (`NA` and `SR`) or isn't included at all (from 2012 onwards).

- The variable `votcorr` is used to identify voters for whom several voting cards have been issued (due to non-receipt, loss, etc.). The cases with
  `votcorr = "A"` have to be filtered out in order to get correct results.
  
  - For unknown reasons this variable is not included in the raw data from 2003 and 2004.
  
  - From `2015-04-19` onwards, there's also the variable `votdup` (coded `0` and `1`) which serves the exact same purpose. There's one case in the raw data
    from `2015-10-18` where `votcorr` and `votdup` contradict each other (`votcorr == "A" & votdup == "0"`) for unknown reasons.

- The variable `typvot` (renamed to `vote_channel`) is used to specify the vote channel. Possible values include:

  - `"A"` = Vote anticipé au local unique prévu à cet effet
  - `"C"` = Par correspondance
  - `"G"` = Au "guichet" (divers types de vote non compris dans les autres catégories)
  - `"I"` = Par Internet
  - `"Z"` = Au local de vote
  - `"Vide"` = Pas voté

- The variable `xnoref` (renamed to `id`) is a personal reference number _uniquely identifying the voter across all the raw data_.

```{r}
#' Read in raw data files from the canton of Geneva
#'
#' @inheritParams read_raw_data
#' @param specific_datasets If not `NULL`, only the specified filenames will be processed. A list with ballot dates as keys and character vectors of specific
#'   filenames (without the filetype extension) as values.
#' @param check_municipalities Check if `municipality` could be determined for all entries excluding Swiss living abroad. A logical scalar.
#' @param remove_duplicated_votes Remove duplicate votes (where `votcorr == "A" | votdup == "1"`; only if the necessary variable exists). A logical scalar. The
#'   variable `votcorr` is used to identify voters for whom several voting cards have been issued (due to non-receipt, loss, etc.). The dummy variable `votdup`
#'   serves the exact same purpose. The cases with `votcorr = "A"` (or `votdup = "1"`) have to be filtered out in order to get correct results. In the (very
#'   rare) case both variables are included and contradict each other, `votdup` is given preference.
#' @param remove_unknown_municipality_district_combos Ignore rows in raw data that are _not_ Swiss abroad but missing a `municipality` (usually with the
#'   undocumented district code `99`). A logical scalar.
#' @param remove_NA_locality_codes Ignore rows in raw data that have no `municipality_code_2_digits` set (`NA`). A logical scalar.
#' @param skip_problematic_dates Skip `ballot_date`s for which unresolved parsing problems exist. A logical scalar.
#'
#' @return A list with a tibble of each raw data file plus metadata tibble.
read_raw_data_geneva <- function(ballot_date,
                                 specific_datasets = NULL,
                                 check_municipalities = TRUE,
                                 remove_duplicated_votes = TRUE,
                                 remove_unknown_municipality_district_combos = FALSE,
                                 remove_NA_locality_codes = FALSE,
                                 skip_problematic_dates = FALSE) {
  
  # get filename(s) of Geneva dataset(s)
  filenames <-
    metadata_geneva_raw_datasets %>%
    dplyr::filter(ballot_date == !!ballot_date
                  & is_e_voting_available) %$%
    filename
  
  # abort if all files are missing
  if (length(filenames) == 0L) {
    
    rlang::abort(glue::glue("There is no raw data file available for Geneva @ {ballot_date}. See `swissevote:::metadata_geneva_raw_datasets`."))
  }
  
  # warn if some files are unknown
  if (any(is.na(filenames))) {
    
    na_notes <-
      metadata_geneva_raw_datasets %>%
      dplyr::filter(ballot_date == !!ballot_date
                    & is_e_voting_available) %$%
      notes %>%
      dplyr::first() %>%
      magrittr::extract(!is.na(.))
    
    rlang::abort(glue::glue("The raw data filename for Geneva @ {ballot_date} ",
                            dplyr::if_else(length(na_notes) > 0L,
                                           "({na_notes}) ",
                                           ""),
                            "is unknown. Check `swissevote:::metadata_geneva_raw_datasets`."))
  }
  
  filenames %<>% magrittr::extract(!is.na(.))
  
  # take `specific_datasets` into account
  if (!is.null(specific_datasets[[ballot_date]])
      & length(filenames)) {
    
    filenames %<>% magrittr::extract(. %in% specific_datasets[[ballot_date]])
  }
  
  # create empty list
  data_raw_list <- list()
  
  # workaround: skip processing of problematic voting register datasets
  ## define the affected dates
  problematic_dates <- c("2004-09-26",
                         "2004-11-28",
                         "2005-04-24",
                         "2008-11-30")
  # NOTES: all the above 4 dates show the undocumented combo of
  #        `municipality_code_2_digits = 21` and `district_code = 99`
  #
  # TODO: get at the bottom of this!
  
  ## skip them all
  if (skip_problematic_dates &
      ballot_date %in% problematic_dates) {
    
    rlang::warn(glue::glue("Skipped processing data from {ballot_date} due to unresolved issues."))
    
  } else {
    
    # read in dataset file(s) and generate metadata
    # TODO: change metadata structure -> a 
    metadata <- tibble::tibble(file = character(),
                               incl_federal = logical(),
                               incl_cantonal = logical(),
                               incl_municipal = logical())
    
    for (filename in filenames) {
      
      metadata_geneva_raw_datasets_subset <- metadata_geneva_raw_datasets %>% dplyr::filter(ballot_date == !!ballot_date
                                                                                            & filename == !!filename)
      data_raw <- read_raw_dataset_geneva(filename = filename,
                                          check_municipalities = check_municipalities,
                                          remove_unknown_municipality_district_combos = remove_unknown_municipality_district_combos,
                                          remove_NA_locality_codes = remove_NA_locality_codes,
                                          remove_duplicated_votes = remove_duplicated_votes)
      
      # skip empty dataframes (no raw data found)
      if (nrow(data_raw)) {
        
        data_raw_list[[filename]] <- data_raw
        
        metadata %<>% tibble::add_row(file = filename,
                                      incl_federal = metadata_geneva_raw_datasets_subset$is_federal,
                                      incl_cantonal = metadata_geneva_raw_datasets_subset$is_cantonal,
                                      incl_municipal = metadata_geneva_raw_datasets_subset$is_municipal)
      }
    }
    
    # append metadata to returned object
    data_raw_list %<>% c(list(metadata = metadata))
  }
  
  data_raw_list
}

read_raw_dataset_geneva <- function(filename,
                                    check_municipalities,
                                    remove_unknown_municipality_district_combos,
                                    remove_NA_locality_codes,
                                    remove_duplicated_votes,
                                    metadata_municipalities_districts = metadata_geneva_municipalities_districts) {
  
  # assemble partial file path
  file_path <- path_raw_data("GE", filename)
  
  # determine file type (prefer CSV > ZIP > XLSX)
  file_type <- filetype_data_raw(file_path = file_path)
  
  # read in data
  ## if file couldn't be found, print a warning and return an empty tibble
  if (is.na(file_type)) {
    
    rlang::warn(glue::glue("File {file_path} neither found in XLSX nor in CSV or ZIP format!"))
    
    return(tibble::tibble())
    
  } else if (file_type == "xlsx") {
    
    data_raw <- readxl::read_excel(path = fs::path(file_path,
                                                   ext = file_type),
                                   col_types = "text",
                                   skip = 0L)
    
  } else {
    
    data_raw <-
      readr::read_file(file = fs::path(file_path,
                                       ext = file_type)) %>%
      # remove carriage return characters (otherwise data will be corrupted due to incorrect row splitting)
      stringr::str_remove_all(pattern = "\\r") %>%
      readr::read_delim(delim = ";",
                        trim_ws = TRUE,
                        # handle all columns as type character (in order to avoid information loss due to strange values)
                        col_types = readr::cols(.default = readr::col_character()),
                        skip = 0L)
  }
  
  # rename columns and convert locality code vars to type integer
  data_raw %<>%
    dplyr::rename(vote_channel = typvot,
                  sex = sexe,
                  marital_status = cec,
                  year_of_birth = dnaisaa,
                  municipality_code_2_digits = votcom,
                  country_canton_code = cnat,
                  year = annee,
                  vote_date = date,
                  is_eligible_federal = qualfed,
                  is_eligible_cantonal = qualcan,
                  is_eligible_municipal = qualcom,
                  district_code = votarr,
                  id = xnoref) %>%
    dplyr::mutate(dplyr::across(c(country_canton_code,
                                  municipality_code_2_digits,
                                  district_code),
                                as.integer))
  
  # cols which are only included in a subset of all datasets
  ## age
  if ("agerevolu" %in% colnames(data_raw)) {
    
    data_raw %<>%
      dplyr::mutate(age = as.integer(agerevolu)) %>%
      dplyr::select(-agerevolu)
  }
  
  ## ballot date
  if ("datvot" %in% colnames(data_raw)) {
    
    data_raw %<>% dplyr::rename(ballot_date = datvot)
  }
  
  ## eligibility type (Swiss living in Switzerland, Swiss abroad, foreigner)
  if ("typelec" %in% colnames(data_raw)) {
    
    data_raw %<>% dplyr::rename(eligibility_type = typelec)
  }
  
  ## e-voting card number
  if ("norefnet" %in% colnames(data_raw)) {
    
    data_raw %<>% dplyr::rename(e_vote_id = norefnet)
  }
  
  ## year/date of birth
  if ("dnaisaa" %in% colnames(data_raw)) {
    
    data_raw %<>%
      dplyr::mutate(year_of_birth = as.integer(dnaisaa)) %>%
      dplyr::select(-dnaisaa)
    
  } else if ("dnais" %in% colnames(data_raw)) {
    
    data_raw %<>% dplyr::mutate(year_of_birth = as.integer(lubridate::year(suppressWarnings(lubridate::dmy(dnais)))))
  }
  
  ## date of birth
  if ("dnais" %in% colnames(data_raw)) {
    
    # there are "invalid" year-only dates like `00001955` included which will be parsed to `NA`
    data_raw %<>%
      dplyr::mutate(date_of_birth = suppressWarnings(lubridate::dmy(dnais))) %>%
      dplyr::select(-dnais)
  }
  
  # remove duplicate votes (where `votcorr == "A" | votdup == "1"`; only if the necessary variable exists)
  if (remove_duplicated_votes && any(c("votcorr", "votdup") %in% colnames(data_raw))) {
    
    # prefer `votdup`
    if ("votdup" %in% colnames(data_raw) && (!checkmate::anyMissing(data_raw[["votdup"]]) || !("votcorr" %in% colnames(data_raw)))) {
      
      data_raw %<>% dplyr::filter(votdup != "1")
      
    } else {
      
      data_raw %<>% dplyr::filter(is.na(votcorr))
    }
  }
  
  # add binary variable `has_voted`
  data_raw %<>% dplyr::mutate(has_voted = dplyr::case_when(is.na(vote_date) ~ NA,
                                                           !(as.integer(vote_date) %in% c(19000101L, 0L)) ~ TRUE,
                                                           TRUE ~ FALSE))
  
  # add binary variable `is_swiss_living_abroad`
  ## check if there are entries with no `municipality_code_2_digits` (`NA`)
  ### get number of affected entries
  nr_of_NA_municipality_code_2_digits <- length(which(is.na(data_raw$municipality_code_2_digits)))
  
  if (nr_of_NA_municipality_code_2_digits > 0L) {
    
    ### print an informative warning
    rlang::warn(glue::glue("{nr_of_NA_municipality_code_2_digits} of a total of {nrow(data_raw)} entries in the raw Geneva data file {filename} have no ",
                           "`municipality_code_2_digits` set (`NA`)!", dplyr::if_else(remove_NA_locality_codes,
                                                                                      " They have been removed.",
                                                                                      "")))
    
    if (remove_NA_locality_codes) {
      
      ### remove affected entries
      data_raw %<>% dplyr::filter(!is.na(municipality_code_2_digits))
    }
  }
  ## generate `is_swiss_living_abroad`
  ## NOTICE: code 46 only available in dates >= 2015-06-14
  data_raw$is_swiss_living_abroad <- data_raw$municipality_code_2_digits == 46L
  
  # add binary variable `is_foreigner`
  ## check if there are entries with no `country_canton_code` (`NA`)
  ### get number of affected entries
  nr_of_NA_country_canton_code <- length(which(is.na(data_raw$country_canton_code)))
  
  if (nr_of_NA_country_canton_code > 0L) {
    
    ### print an informative warning
    rlang::warn(glue::glue("{nr_of_NA_country_canton_code} of a total of {nrow(data_raw)} entries in the raw Geneva data file {filename} have no ",
                           "`country_canton_code` set (`NA`)!", dplyr::if_else(remove_NA_locality_codes,
                                                                               " They have been removed.",
                                                                               "")))
    
    ### remove affected entries
    if (remove_NA_locality_codes) {
      
      data_raw %<>% dplyr::filter(!is.na(country_canton_code))
    }
  }
  ## generate `is_foreigner`
  data_raw$is_foreigner <- !data_raw$is_swiss_living_abroad & data_raw$country_canton_code > 99L
  
  # add `municipality` and `district`
  ## fix "wrong" district codes in raw data (`01` instead of `00` as documented in the codebook)
  ### get all indices of municipalities with only one district code (excl. Swiss abroad)
  affected_indices <-
    data_raw %>%
    dplyr::filter(municipality_code_2_digits != 46L & district_code != 0L) %>%
    dplyr::select(municipality_code_2_digits, district_code) %>%
    unique() %>%
    dplyr::group_by(municipality_code_2_digits) %>%
    dplyr::summarise(n = dplyr::n(),
                     .groups = "drop") %>%
    dplyr::filter(n == 1L) %$%
    municipality_code_2_digits %>%
    magrittr::is_in(data_raw$municipality_code_2_digits, .) %>%
    which()
  
  ### get the district codes of the affected entries
  affected_district_codes <- unique(data_raw$district_code[affected_indices])
  
  ### replace `1` with `0` and print a warning about it
  if (length(affected_indices) > 0L) {
    
    rlang::warn(glue::glue("There were {length(affected_indices)} entries in the raw Geneva data file {filename} that had a \"wrong\" district code set. ",
                           "They have been fixed.\nThe wrong district codes included the following numbers: ", pal::prose_ls(affected_district_codes)))
    
    data_raw$district_code[affected_indices] <- 0L
  }
  ## add municipality and district names
  data_raw %<>%
    dplyr::left_join(y = metadata_municipalities_districts,
                     by = c("municipality_code_2_digits", "district_code")) %>%
    # we can simply ignore `void_since` because all `municipality_code_2_digits`-`district_code` combos are unique anyway
    dplyr::select(-void_since)
  
  # check if `municipality` could be determined for all entries excl. Swiss living abroad
  if (check_municipalities) {
    
    ## determine entries missing a municipality (mostly with the undocumented district code `99`)
    unknown_municipality_district_combos <-
      data_raw %>%
      dplyr::filter(!is_swiss_living_abroad
             & is.na(municipality))
    
    if (nrow(unknown_municipality_district_combos)) {
      
      ## TODO: get rid of this assignment once we're certain we're properly handling unknown combos.
      ## save missing municipalities to global environment
      assign(x = paste0("unknown_municipality_district_combos_GE_", filename),
             value = data_raw %>% dplyr::filter(!is_swiss_living_abroad
                                                & is.na(municipality)),
             pos = globalenv())
      
      ## print a warning with some hints
      rlang::warn(glue::glue("For {nrow(unknown_municipality_district_combos)} of a total of {nrow(data_raw)} entries in the raw Geneva data file {filename} ",
                             "no matching municipality could be found! This can either be due to flaws/errors in the data or because ",
                             "`metadata_geneva_raw_datasets` needs an update.", dplyr::if_else(remove_unknown_municipality_district_combos,
                                                                                               " The affected entries have been removed. To inspect them",
                                                                                               " To inspect the affected entries"),
                             ", enter: `View(unknown_municipality_district_combos_GE_{filename})`\n\n",
                             "The affected entries show the following combinations of `municipality_code_2_digits` and `district_code`:\n\n    ",
                             unknown_municipality_district_combos %>%
                               dplyr::select(municipality_code_2_digits, district_code) %>%
                               dplyr::arrange(municipality_code_2_digits, district_code) %>%
                               unique() %>%
                               pal::pipe_table(strong_colnames = FALSE)))
      
      ## remove unknown municipalities
      if (remove_unknown_municipality_district_combos) {
        
        data_raw %<>% dplyr::anti_join(y = unknown_municipality_district_combos,
                                       by = colnames(data_raw))
      }
    }
  }
  
  data_raw
}
```

### Neuchatel

```{r}
read_raw_data_neuchatel <- function(ballot_date) {
  
  # define column names and types depending on `ballot_date`
  if (lubridate::year(ballot_date) < 2016L) {
    
    col_names_types <- tibble::tribble(
      
      ~name,                    ~type,
      "municipality",           "text",
      "age",                    "numeric",
      "date",                   "date",
      "sex",                    "text",
      "vote_channel",           "text",
      "vote_date",              "date",
      "nr_of_voters",           "numeric",
      "nr_of_votes",            "numeric",
      "is_swiss_living_abroad", "logical",
      "nationality_code",       "numeric",
      "nationality",            "text"
    )
    
    col_types_csv <- "cicccciilic"
    
  } else {
    
    col_names_types <- tibble::tribble(
      
      ~name,                    ~type,
      "age",                    "numeric",
      "municipality",           "text",
      "date",                   "date",
      "sex",                    "text",
      "vote_channel",           "text",
      "vote_date",              "date",
      "nr_of_voters",           "numeric",
      "nr_of_votes",            "numeric",
      "is_swiss_living_abroad", "logical",
      "nationality_code",       "numeric",
      "nationality",            "text"
    )
    
    col_types_csv <- "iccccciilic"
  }
  
  # assemble partial file path
  file_path <- path_raw_data(glue::glue("NE/NE_{ballot_date}"))
  
  # determine file type
  file_type <- filetype_data_raw(file_path = file_path)
  
  # read in data
  if (is.na(file_type)) {
    
    # if file couldn't be found, print a warning and return an empty tibble
    rlang::warn(glue::glue("File {file_path} neither found in XLSX nor in CSV or ZIP format!"))
    
    return(tibble::tibble())
    
  } else if (file_type == "xlsx") {
    
    data_raw <- readxl::read_excel(path = fs::path(file_path,
                                                   ext = file_type),
                                   col_names = col_names_types$name,
                                   col_types = col_names_types$type,
                                   skip = 1L)
    
  } else {
    
    data_raw <- readr::read_csv(file = fs::path(file_path,
                                                ext = file_type),
                                col_names = col_names_types$name,
                                col_types = col_types_csv,
                                trim_ws = TRUE,
                                skip = 1L)
  }
  
  # perform some naive integrity checks
  ## ensure header line isn't mistakenly included (happens when file contains surplus rows at the beginning)
  if (data_raw %>%
      as.matrix() %>%
      .[!is.na(.)] %>%
      stringr::str_detect(pattern = "(?i)(ele (libell\u00e9|sexe|)|car mode votation)") %>%
      any()) {
    
    rlang::abort(glue::glue("The NE data file ", fs::path(file_path, ext = file_type),
                            " seems to contain empty surplus rows at the beginning! Please remove them and try again."))
  }
  
  ## add binary variable `is_foreigner`
  data_raw$is_foreigner <- dplyr::case_when(is.na(data_raw$nationality) ~ NA,
                                            data_raw$nationality == "Suisse" ~ FALSE,
                                            TRUE ~ TRUE)
  
  ## check for missing nationalities
  if (any(is.na(data_raw$is_foreigner))) {
    
    rlang::warn(glue::glue("Found ", length(which(is.na(data_raw$is_foreigner))), " entries in raw data lacking a nationality (`NA`)! Please double-check ",
                           "raw data from {ballot_date}."))
  }
  
  ## check for invalid data
  if (data_raw %>%
      dplyr::filter(is_foreigner & is_swiss_living_abroad) %>%
      nrow() %>%
      magrittr::is_greater_than(0L)) {
    
    rlang::abort("Found Swiss abroad data entry in raw data with nationality other than Suisse! Please double-check data.")
  }
  
  data_raw
}
```

# Scrape ballot dates from the authorities' websites

TODO: Completely overhaul the architecture to scrape all the sites, reducing unnecesary redundancy. Export a single fn `ballot_dates()` that relies on internal
      pkg functions. Use caching at the appropriate places (currently not optimal) using `pkgpins::with_cache()` only.

**Remarks:**

- Note that, with the exception of the Canton (but not the municipality) of Zurich, the exclusion of indirect counterproposals and tie-breaker questions is
  done based on some fuzzy string detection; double-check the resulting `nr_of_*_referendums` to be on the safe side!

## Get latest ballot dates from Neuchatel's official website

**Remarks:**

- The latest ballot dates are on a separate page (<https://www2.ne.ch/vote>), not separated by political level.

```{r}
ballot_dates_latest_neuchatel <- function() {
  
  ballot_dates <- tibble::tibble(ballot_date = lubridate::as_date(integer()),
                                 level = character(),
                                 municipality = character(),
                                 is_election = logical(),
                                 subject = character())
  
  raw_extract <-
    xml2::read_html(x = "https://www2.ne.ch/vote",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "table") %>%
    magrittr::extract2(4L) %>%
    rvest::html_nodes(css = "td")
  
  level_i <- NA
  
  for (i in seq_along(raw_extract)) {
    
    if (isTRUE(rvest::html_attr(x = raw_extract[[i]],
                                name = "class") == "VotationType")) {
      
      level_i <- switch(EXPR = rvest::html_text(x = raw_extract[[i]]),
                        "Scrutins f\u00e9d\u00e9raux" = "federal",
                        "Scrutins cantonaux" = "cantonal",
                        "Scrutins communaux" = "municipal")
      
    } else if (isTRUE(raw_extract[[i]] %>%
                      rvest::html_nodes(css = "a") %>%
                      rvest::html_attr(name = "class") %>%
                      magrittr::equals("SubSectionTitle"))
               & !is.na(level_i)) {
      
      text_i <-
        raw_extract[[i]] %>%
        rvest::html_text() %>%
        stringr::str_squish() %>%
        stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                             replacement = "\\1 \\4\\2") %>%
        stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                           simplify = FALSE) %>%
        purrr::flatten_chr()
      
      ballot_dates %<>% tibble::add_row(ballot_date = lubridate::dmy(text_i[2L]),
                                        level = level_i,
                                        municipality = dplyr::if_else(condition = level == "municipal",
                                                                      true =
                                                                        text_i[1L] %>%
                                                                        stringr::str_extract(pattern = "^.+?(?= - )") %>%
                                                                        stringr::str_replace_all(pattern = "Les Geneveys s/Coffrane",
                                                                                                 replacement = "Les Geneveys-sur-Coffrane"),
                                                                      false = NA_character_),
                                        is_election = stringr::str_detect(string = text_i[1L],
                                                                          pattern = "(?i) - (e|\u00e9)lection"),
                                        subject = dplyr::if_else(condition = level == "municipal",
                                                                 true = stringr::str_extract(string = text_i[1L],
                                                                                             pattern = "(?<= - ).*$"),
                                                                 false = text_i[1L]))
    }
  }
  
  ballot_dates %>% dplyr::arrange(ballot_date, level, is_election)
}
```

## Get federal ballot dates

```{r}
#' Get federal ballot dates
#'
#' @param source Federal ballot dates can either be retrieved from the official website of the canton of _Neuchatel_ (default) or _Zurich_. Note that only
#'   referendum dates will be returned from `source = "Zurich"`, election dates can only be scraped from `source = "Neuchatel"`. On the other hand,
#'   `source = "Zurich"` will return referendum dates back to the 19th century, while `source = "Neuchatel"` only goes back to the turn of the millennium.
#' @param exclude_counterproposals Exclude indirect counterproposals and tie-breaker questions. A logical scalar.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")`
#'
#' @return `pkgsnippets::return_label("data")`
#' @export
ballot_dates_federal <- function(source = c("Neuchatel", "Zurich"),
                                 exclude_counterproposals = TRUE,
                                 use_cache = TRUE,
                                 cache_lifespan = "1 day") {
  
  pkgpins::with_cache(
    .fn = function(source,
                   exclude_counterproposals) {
      
      result <- switch(EXPR = source,
                       "Neuchatel" =
                         ballot_dates_federal_neuchatel(exclude_counterproposals = exclude_counterproposals),
                       "Zurich" =
                         get_zurich_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                         dplyr::filter(level == "federal") %>%
                         dplyr::select(ballot_date, subject) %>%
                         dplyr::transmute(ballot_date,
                                          is_election = FALSE,
                                          limited_to_cantons = NA_character_,
                                          subject))
      
      # incorporate GE Council of States ballot dates
      result %>%
        dplyr::bind_rows(get_geneva_election_dates() %>%
                           dplyr::filter(level == "federal"
                                         & !(ballot_date %in% result$ballot_date)
                                         & ballot_date > min(result$ballot_date)) %>%
                           dplyr::transmute(ballot_date,
                                            is_election = TRUE,
                                            limited_to_cantons = "Geneva",
                                            subject = subject_summary)) %>%
        dplyr::arrange(ballot_date, is_election)
    },
    source = rlang::arg_match(source),
    exclude_counterproposals = exclude_counterproposals,
    .use_cache = use_cache,
    .cache_lifespan = cache_lifespan,
    .pkg = pkg
  )
}
```

##### From Neuchatel's official website

This function scrapes the federal ballot dates and subjects from <https://www2.ne.ch/vote/AnciensScrutinsFederaux.asp> and returns them as a tibble.

```{r}
ballot_dates_federal_neuchatel <- function(exclude_counterproposals = FALSE) {
  
  # get archived ballot dates
  ballot_dates <-
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsFederaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "ballot_date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(ballot_date = lubridate::dmy(ballot_date),
                     is_election = stringr::str_detect(string = subject,
                                                       pattern = "(?i)^(e|\u00e9)lection"),
                     limited_to_cantons = NA_character_,
                     subject = subject)
  
  # incorporate latest ballot dates (separate page)
  ballot_dates %<>% dplyr::bind_rows(ballot_dates_latest_neuchatel() %>%
                                       dplyr::filter(level == "federal") %>%
                                       dplyr::transmute(ballot_date,
                                                        is_election,
                                                        limited_to_cantons = NA_character_,
                                                        subject))
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    ballot_dates %<>%
      dplyr::filter(!(!is_election
                      & stringr::str_detect(string = subject,
                                            pattern = regex_counterproposal_fr))) %>%
      # manually exclude remaining cases
      dplyr::filter(!(ballot_date == "2002-09-22"
                     & subject == "L'or \u00e0 l'AVS, aux cantons et \u00e0 la Fondation\""))
  }
  
  # incorporate Council of States election dates
  ballot_dates %>%
    dplyr::filter(is_election) %>%
    dplyr::bind_rows(get_neuchatel_cantonal_ballot_dates(council_of_states = TRUE) %>%
                       dplyr::transmute(ballot_date,
                                        is_election,
                                        limited_to_cantons = dplyr::if_else(ballot_date %in% ballot_dates$ballot_date,
                                                                            NA_character_,
                                                                            "Neuchatel"),
                                        subject)) %>%
    dplyr::group_by(ballot_date, is_election, limited_to_cantons) %>%
    dplyr::summarise(subject = paste0(subject,
                                      collapse = "; "),
                     .groups = "drop") %>%
    dplyr::bind_rows(ballot_dates %>% dplyr::filter(!is_election)) %>%
    dplyr::arrange(ballot_date, is_election)
}
```

## Get cantonal ballot dates

**Remarks:**

- Note that Genevan Council of States election dates might have only `"Elections fédérales"` set as `subject` if the Council of States was elected at the same date as the National Council (usually the case for the first round of voting).

```{r}
#' Get cantonal ballot dates
#'
#' @param cantons The names of the cantons to retrieve ballot dates for. A character vector.
#' @inheritParams ballot_dates_federal
#'
#' @inherit ballot_dates_federal return
#' @export
ballot_dates_cantonal <- function(cantons = c("Geneva", "Neuchatel", "Zurich"),
                                  exclude_counterproposals = TRUE,
                                  use_cache = TRUE,
                                  cache_lifespan = "1 day") {
  
  pkgpins::with_cache(
    .fn = function(cantons,
                   exclude_counterproposals) {
      
      ballot_dates <- tibble::tibble(ballot_date = lubridate::as_date(integer()),
                                     canton = character(),
                                     is_election = logical(),
                                     subject = character())
      
      for (canton in cantons) {
        
        # print warning ...
        switch(EXPR = canton,
               # ... about missing ZH election dates
               "Zurich" = rlang::warn(glue::glue("For the canton of {canton} only referendum dates can be scraped. The cantonal election dates have to be ",
                                                 "gathered by hand.")))
        
        if (canton %in% c("Neuchatel", "Zurich")) {
          
          ballot_dates <-
            switch(EXPR = canton,
                   "Geneva" =
                     get_geneva_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::filter(level == "cantonal") %>%
                     dplyr::transmute(ballot_date,
                                      subject,
                                      is_election = FALSE) %>%
                     dplyr::bind_rows(get_geneva_election_dates() %>%
                                        dplyr::filter(level == "cantonal") %>%
                                        dplyr::transmute(ballot_date,
                                                         subject = subject_summary,
                                                         is_election = TRUE)) %>%
                     dplyr::mutate(canton = "Geneva"),
                   "Neuchatel" =
                     get_neuchatel_cantonal_ballot_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::mutate(canton = "Neuchatel"),
                   "Zurich" =
                     get_zurich_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                     dplyr::filter(level == "cantonal") %>%
                     dplyr::mutate(canton = "Zurich",
                                   is_election = FALSE) %>%
                     dplyr::select(ballot_date, canton, is_election, subject)) %>%
            dplyr::select(ballot_date, canton, is_election, subject) %>%
            dplyr::full_join(y = ballot_dates,
                             by = colnames(ballot_dates))
        } else {
          rlang::warn(glue::glue("Scraping ballot dates from the canton of {canton} hasn't been implemented yet!"))
        }
      }
      
      ballot_dates %>% dplyr::arrange(ballot_date, canton, is_election)
    },
    cantons = rlang::arg_match(cantons),
    exclude_counterproposals = exclude_counterproposals,
    .use_cache = use_cache,
    .cache_lifespan = cache_lifespan,
    .pkg = pkg
  )
}
```

## Get municipal ballot dates

```{r}
#' Get municipal ballot dates
#'
#' @inheritParams ballot_dates_cantonal
#' @inheritParams ballot_dates_federal
#'
#' @inherit ballot_dates_federal return
#' @export
ballot_dates_municipal <- function(cantons = c("Geneva", "Neuchatel", "Zurich"),
                                   exclude_counterproposals = TRUE,
                                   use_cache = TRUE,
                                   cache_lifespan = "1 day") {
  
  
  
  pkgpins::with_cache(
    .fn = function(cantons,
                   exclude_counterproposals) {
      
      ballot_dates <- tibble::tibble(ballot_date = lubridate::as_date(integer()),
                                     canton = character(),
                                     municipality = character(),
                                     is_election = logical(),
                                     subject = character())
      
      for (canton in cantons) {
        
        ballot_dates <-
          switch(EXPR = canton,
                 
                 "Geneva" =
                   get_geneva_referendum_dates(exclude_counterproposals = exclude_counterproposals) %>%
                   dplyr::filter(level == "municipal") %>%
                   dplyr::transmute(ballot_date,
                                    municipality,
                                    is_election = FALSE,
                                    subject) %>%
                   dplyr::bind_rows(get_geneva_municipal_election_dates() %>%
                                      dplyr::transmute(ballot_date,
                                                       municipality,
                                                       is_election = TRUE,
                                                       subject)) %>%
                   dplyr::mutate(canton = "Geneva"),
                 
                 "Neuchatel" =
                   get_neuchatel_municipal_ballot_dates(exclude_counterproposals = exclude_counterproposals) %>%
                   dplyr::mutate(canton = "Neuchatel"),
                 
                 "Zurich" =
                   get_zurich_municipal_ballot_dates(exclude_counterproposals = exclude_counterproposals) %>%
                   dplyr::mutate(canton = "Zurich")) %>%
          dplyr::select(ballot_date, canton, municipality, is_election, subject) %>%
          dplyr::full_join(y = ballot_dates,
                           by = colnames(.))
      }
      
      ballot_dates %>% dplyr::arrange(ballot_date, canton, municipality, is_election)
    },
    cantons = rlang::arg_match(cantons),
    exclude_counterproposals = exclude_counterproposals,
    .use_cache = use_cache,
    .cache_lifespan = cache_lifespan,
    .pkg = pkg
  )
}
```

#### Neuchatel

##### Get cantonal ballot dates from Neuchatel's official website

**Remarks:**

- This function scrapes the cantonal ballot dates and subjects from <https://www2.ne.ch/vote/AnciensScrutinsCantonaux.asp> and returns them as a dataframe.

- If `council_of_states` is set to `TRUE`, the Neuchatel election dates of the Council of States (federal level) are returned instead of the cantonal ballot
  dates.

- Set the parameter `exclude_counterproposals` to `TRUE` in order to exclude indirect counterproposals and tie-breaker questions.

```{r}
get_neuchatel_cantonal_ballot_dates <- function(council_of_states = FALSE,
                                                exclude_counterproposals = FALSE) {
  # get archived ballot dates
  ballot_dates <-
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsCantonaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "ballot_date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(ballot_date = lubridate::dmy(ballot_date),
                     is_election = stringr::str_detect(string = subject,
                                                       pattern = "(?i)^election"),
                     subject = subject)
  
  # incorporate latest ballot dates (separate page)
  ballot_dates %<>% dplyr::bind_rows(ballot_dates_latest_neuchatel() %>%
                                       dplyr::filter(level == "cantonal") %>%
                                       dplyr::select(ballot_date,
                                                     is_election,
                                                     subject))
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    ballot_dates %<>% dplyr::filter(!(!is_election
                                      & stringr::str_detect(string = subject,
                                                            pattern = regex_counterproposal_fr)))
  }
  
  # return cantonal ballot dates or elections of the Council of States?
  regex <- "(?i)conseil\\s+des\\s+.tats"
  
  if (council_of_states) {
    
    ballot_dates %<>% dplyr::filter((is_election
                                     & stringr::str_detect(string = subject,
                                                           pattern = regex)))
  } else {
    
    ballot_dates %<>% dplyr::filter(!(is_election
                                      & stringr::str_detect(string = subject,
                                                            pattern = regex)))
  }
  
  ballot_dates %>% dplyr::arrange(ballot_date, is_election)
}
```

##### Get municipal ballot dates from Neuchatel's official website

This function scrapes the municipal ballot dates and subjects from <https://www2.ne.ch/vote/AnciensScrutinsCommunaux.asp> and returns them as a dataframe.

```{r}
get_neuchatel_municipal_ballot_dates <- function(exclude_counterproposals = FALSE) {
  
  ballot_dates <-
    # get archived ballot dates
    xml2::read_html(x = "https://www2.ne.ch/vote/AnciensScrutinsCommunaux.asp",
                    encoding = "windows-1252") %>%
    rvest::html_node(css = "body") %>%
    rvest::html_node(css = "table") %>%
    rvest::html_nodes(css = ".SubSectionTitle") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    stringr::str_replace(pattern = "^(.+?)( - \\d+?\\.\\d+?\\.\\d+)( )(\\(.+?\\))$",
                         replacement = "\\1 \\4\\2") %>%
    stringr::str_split(pattern = " - (?=\\d+?\\.\\d+?.\\d+?$)",
                       simplify = TRUE) %>%
    magrittr::set_colnames(c("subject", "ballot_date")) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(ballot_date = lubridate::dmy(ballot_date),
                     municipality =
                       subject %>%
                       stringr::str_extract(pattern = "^.+?(?= - )") %>%
                       stringr::str_replace_all(pattern = "Les Geneveys s/Coffrane",
                                                replacement = "Les Geneveys-sur-Coffrane"),
                     is_election =
                       subject %>%
                       stringr::str_detect(pattern = "(?i) - (e|\u00e9)lection"),
                     subject =
                       subject %>%
                       stringr::str_extract(pattern = "(?<= - ).*$")) %>%
    # incorporate latest ballot dates (separate page)
    dplyr::bind_rows(ballot_dates_latest_neuchatel() %>%
                       dplyr::filter(level == "municipal") %>%
                       dplyr::select(ballot_date,
                                     municipality,
                                     is_election,
                                     subject)) %>%
    # special cases @ 2008-06-22: municipality mergers weren't effective until 2009-01-01
    # - split "La T\u00e8ne" into "Marin-Epagnier" & "Thielle-Wavre"
    # - split "Val-de-Travers" into "Boveresse", "Buttes", "Couvet", "Fleurier", "Les Bayards", "M\u00f4tiers", "Noiraigue", "Saint-Sulpice" & "Travers"
    dplyr::mutate(municipality = dplyr::case_when(municipality == "La T\u00e8ne" & ballot_date == "2008-06-22" ~ "Marin-Epagnier",
                                                  municipality == "Val-de-Travers" & ballot_date == "2008-06-22" ~ "Boveresse",
                                                  TRUE ~ municipality)) %>%
    tibble::add_row(ballot_date = lubridate::as_date("2008-06-22"),
                    municipality = c("Thielle-Wavre",
                                     "Couvet",
                                     "Fleurier",
                                     "Les Bayards",
                                     "M\u00f4tiers",
                                     "Noiraigue",
                                     "Saint-Sulpice",
                                     "Travers"),
                    is_election = TRUE,
                    subject = c("Election au Conseil g\u00e9n\u00e9ral - La T\u00e8ne",
                                rep(x = "Election au Conseil g\u00e9n\u00e9ral - Val-de-Travers",
                                    times = 7L))) %>%
    dplyr::arrange(ballot_date, municipality)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    ballot_dates %<>% dplyr::filter(!(!is_election
                                      & stringr::str_detect(string = subject,
                                                            pattern = regex_counterproposal_fr)))
  }
  
  ballot_dates
}
```

#### Geneva

##### Get referendum dates from Geneva's official website

**Remarks:**

- This function scrapes the Genevan referendum dates and subjects from <https://www.ge.ch/votations/> and returns them as a dataframe.

- Set the parameter `exclude_counterproposals` to `TRUE` in order to exclude indirect counterproposals and tie-breaker questions.

- Note that it might take some time to scrape _all_ the 90+ ballot dates (minutes at most).

```{r}
get_geneva_referendum_dates <- function(years = 1996:lubridate::year(lubridate::today()),
                                        exclude_counterproposals = FALSE) {
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (year in years) {
    
    referendum_dates %<>% dplyr::bind_rows(get_geneva_referendum_date(year = year))
  }
  
  referendum_dates %<>%
    # ensure correct spelling of "Gen\u00e8ve"
    dplyr::mutate(municipality = dplyr::if_else(condition = municipality == "Geneve",
                                                true = "Gen\u00e8ve",
                                                false = municipality)) %>%
    # arrange columns
    dplyr::transmute(ballot_date, level, municipality, subject) %>%
    # arrange entries
    dplyr::arrange(ballot_date, level, municipality)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    ## define regex to catch them
    regex_counterproposal_only_fr <- "(?i)co?n?tre-?projet(?!\\s(direct|relatif))"
    
    ## define base proposal number regex
    regex_proposal_nr <- "(?i)(?<=\\bin(itiative)?(\\spopulaire)?(\\s|-|_|\\.)?)"
    
    ## get affected combos
    affected_date_proposal_combos <-
      referendum_dates %>%
      dplyr::mutate(proposal_nrs =
                      stringr::str_extract_all(string = subject,
                                               pattern = paste0(regex_proposal_nr, "\\d+")) %>%
                      # count only once per subject
                      purrr::map(unique)) %>%
      dplyr::group_by(ballot_date, level, municipality) %>%
      dplyr::summarise(proposal_nr =
                         proposal_nrs %>%
                         unlist() %>%
                         magrittr::extract(duplicated(.)) %>%
                         list()) %>%
      dplyr::ungroup() %>%
      tidyr::unnest()
    
    ## get affected entries
    to_exclude <- referendum_dates[0L, ]
    
    for (i in seq_len(nrow(affected_date_proposal_combos))) {
      
      to_exclude <-
        referendum_dates %>%
        dplyr::filter(ballot_date == affected_date_proposal_combos$ballot_date[i]
                      & level == affected_date_proposal_combos$level[i]
                      & (municipality == affected_date_proposal_combos$municipality[i]
                         | is.na(municipality) & is.na(affected_date_proposal_combos$municipality[i]))
                      # exclude explicitly numbered indirect counterproposals and tie-breaker questions
                      & ((stringr::str_detect(string = subject,
                                              pattern = paste0(regex_proposal_nr, affected_date_proposal_combos$proposal_nr[i]))
                          & stringr::str_detect(string = subject,
                                                pattern = regex_counterproposal_only_fr))
                         # exclude remaining tie-breaker questions
                         | stringr::str_detect(string = subject,
                                               pattern = "(?i)question\\ssubsidiaire"))) %>%
        dplyr::bind_rows(to_exclude)
    }
    
    ## exclude affected entries
    referendum_dates %<>%
      dplyr::setdiff(y = to_exclude) %>%
      # exclude some special cases (not having a proposal number)
      dplyr::filter(!(municipality == "Versoix" & ballot_date == "2009-05-17" & stringr::str_detect(string = subject,
                                                                                                    pattern = "(?i)(contreprojet|question\\ssubsidiaire)")))
  }
  
  referendum_dates
}
```

###### Gateway to get referendum dates for a specific year

TODO: Meanwhile all the ballot dates were migrated to the new page format (see `scrape_geneva_referendum_date_after_mid_2018()`) and all the GE scraping code
      needs to be updated.

```{r}
get_geneva_referendum_date <- function(year) {
  
  if (year < 2007L) {
    
    referendum_dates <- scrape_geneva_referendum_dates_before_2007(year = year)
    
  } else if (year < 2015L) {
    
    referendum_dates <- scrape_geneva_referendum_dates_between_2007_2014(year = year)
    
  } else {
    
    referendum_dates <- scrape_geneva_referendum_dates_after_2014(year = year)
  }
  
  referendum_dates
}
```

###### Create empty skeleton of Geneva referendum dates

```{r}
get_geneva_referendum_dates_skeleton <- function() {
  
  tibble::tibble(ballot_date = lubridate::as_date(integer()),
                 level = character(),
                 municipality = character(),
                 subject = character())
}
```

###### Scrape referendum dates for a specific year before 2007

**BROKEN!**

Years before 2007 have the same specific format: Yearly subpages with one unordered list per date-level combo.

```{r}
scrape_geneva_referendum_dates_before_2007 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = paste0("https://www.ge.ch/votations/", year, ".asp"),
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure") %>%
    rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (i in seq_along(raw_extract)) {
    
    raw_subextract <-
      raw_extract[[i]] %>%
      rvest::html_nodes(css = "li")
    
    # exclude cancelled proposals (formatted struck through)
    is_cancelled <-
      raw_subextract %>%
      rvest::html_node(css = "span") %>%
      rvest::html_attr(name = "class") %>%
      magrittr::equals("txt_barre") %>%
      purrr::map_lgl(isTRUE)
    
    raw_subextract %<>%
      magrittr::extract(!is_cancelled) %>%
      rvest::html_nodes(css = "a") %>%
      # workaround to remove spurious 2006-11-26 link in 2005 page
      magrittr::extract(rvest::html_text(.) != "")
    
    if (length(raw_subextract)) {
      
      referendum_dates %<>%
        tibble::add_row(ballot_date =
                          raw_subextract %>%
                          rvest::html_attr(name = "href") %>%
                          stringr::str_extract(pattern = "\\d{8}") %>%
                          lubridate::ymd(),
                        level =
                          !!level[i],
                        subject =
                          raw_subextract %>%
                          rvest::html_text() %>%
                          stringr::str_squish(),
                        municipality =
                          dplyr::if_else(condition =
                                           level == "municipal",
                                         true =
                                           subject %>%
                                           stringr::str_extract(pattern = dplyr::if_else(condition = lubridate::year(ballot_date) != 2006L,
                                                                                         true = "^.+?(?=:)",
                                                                                         false = "(?<=\\s)\\S+$")),
                                         false = NA_character_))
    }
  }
  
  referendum_dates %>%
    # remove spurious entries
    dplyr::filter(!is.na(ballot_date) & !is.na(level)) %>%
    # special case 2005 (site structure differs): set correct `municipality`
    dplyr::mutate(municipality = dplyr::if_else(condition =
                                                  level == "municipal" &
                                                  lubridate::year(ballot_date) == 2005L,
                                                true = "Gen\u00e8ve",
                                                false = municipality))
}
```

###### Scrape referendum dates for a specific year between 2007 and 2014

**BROKEN!**

The years 2007–2014 have another specific format: Yearly subpages with no neat `<ul>` structure; instead the subpages are kinda "serialized".

```{r}
scrape_geneva_referendum_dates_between_2007_2014 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = paste0("https://www.ge.ch/votations/", year, ".asp"),
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure")
  
  vote_locations_temp <-
    raw_extract %>%
    rvest::html_nodes(css = "h5") %>%
    rvest::html_text() %>%
    stringr::str_trim() %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$")
  
  raw_extract %<>%
    rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  vote_locations <- level
  vote_locations[!is.na(vote_locations)] <- vote_locations_temp
  rm(vote_locations_temp)
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  ballot_date <- lubridate::as_date(NA)
  
  for (i in seq_along(raw_extract)) {
    
    if (is.na(level[i])) {
      
      ballot_date <-
        raw_extract[[i]] %>%
        rvest::html_nodes(css = "li") %>%
        rvest::html_nodes(css = "a") %>%
        rvest::html_attr(name = "href") %>%
        stringr::str_extract(pattern = "\\d{8}") %>%
        lubridate::ymd()
      
    } else {
      
      raw_subextract <-
        raw_extract[[i]] %>%
        rvest::html_nodes(css = "li")
      
      # exclude cancelled proposals (formatted struck through)
      is_cancelled <-
        raw_subextract %>%
        rvest::html_node(css = "span") %>%
        rvest::html_attr(name = "class") %>%
        magrittr::equals("txt_barre") %>%
        purrr::map_lgl(isTRUE)
      
      raw_subextract %<>%
        magrittr::extract(!is_cancelled)
      
      if (length(raw_subextract)) {
        
        referendum_dates %<>% tibble::add_row(ballot_date = !!ballot_date,
                                              level = !!level[i],
                                              municipality = vote_locations[i],
                                              subject =
                                                raw_subextract %>%
                                                rvest::html_text() %>%
                                                stringr::str_squish())
      }
    }
  }
  
  # set `municipality` to NA again if `level` isn't municipal
  referendum_dates %>% dplyr::mutate(municipality = dplyr::if_else(condition = level == "municipal",
                                                                   true = municipality,
                                                                   false = NA_character_))
}
```

###### Scrape referendum dates for a specific year after 2014

**BROKEN!**

Years after 2014 have again another specific format: One unordered list per year with each item linking to a specific subpage per ballot date.

```{r}
scrape_geneva_referendum_dates_after_2014 <- function(year) {
  
  raw_extract <-
    xml2::read_html(x = "https://www.ge.ch/votations/welcome.asp",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure") %>%
    rvest::html_nodes(css = "ul")
  
  is_relevant_year <-
    raw_extract %>%
    as.character() %>%
    stringr::str_extract(pattern = "\\d{8}") %>%
    lubridate::ymd() %>%
    lubridate::year() %>%
    magrittr::is_in(year)
  
  raw_extract %<>%
    magrittr::extract(is_relevant_year) %>%
    rvest::html_nodes(css = "li")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  ## process ballot-date-specific subpages
  for (i in seq_along(raw_extract)) {
    
    href <-
      raw_extract[i] %>%
      rvest::html_nodes(css = "a") %>%
      rvest::html_attr(name = "href")
    
    # skip dates lacking a link to a subpage (supposedly preliminary)
    if (length(href)) {
      
      ballot_date <-
        href %>%
        stringr::str_extract(pattern = "\\d{8}") %>%
        lubridate::ymd()
      
      subpage_url <- paste0("https://www.ge.ch", href)
      
      # subpage format has changed from 2018-09-23 onwards
      if (ballot_date < "2018-09-23") {
        
        referendum_dates %<>% dplyr::bind_rows(scrape_geneva_referendum_date_between_2014_mid_2018(ballot_date = ballot_date,
                                                                                                   url = subpage_url))
      } else {
        
        referendum_dates %<>% dplyr::bind_rows(scrape_geneva_referendum_date_after_mid_2018(ballot_date = ballot_date,
                                                                                            url = subpage_url))
      }
    }
  }
  
  referendum_dates
}
```

###### Scrape a referendum date between 2014 and 2018-06-10

This function scrapes the ballot-date-specific subpages of the old format. The ballot-date-specific subpages from `2018-09-23` onwards are hosted on a new
site.

```{r}
scrape_geneva_referendum_date_between_2014_mid_2018 <- function(ballot_date,
                                                                url) {
  raw_extract <-
    xml2::read_html(x = url,
                    # subpage format has changed from 2018-09-23 onwards
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = "#texte_bordure")
  
  vote_locations <-
    raw_extract %>%
    rvest::html_nodes(css = "h4") %>%
    rvest::html_text() %>%
    stringr::str_trim() %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$")
  
  raw_extract %<>% rvest::html_nodes(css = "ul")
  
  level <-
    raw_extract %>%
    rvest::html_attr(name = "class") %>%
    stringr::str_replace(pattern = "communal",
                         replacement = "municipal")
  
  referendum_dates <- get_geneva_referendum_dates_skeleton()
  
  for (i in seq_along(raw_extract)) {
    
    if (!is.na(level[i])) {
      
      raw_subextract <-
        raw_extract[i] %>%
        rvest::html_nodes(css = "li")
      
      # exclude cancelled proposals (formatted struck through)
      is_cancelled <-
        raw_subextract %>%
        rvest::html_node(css = "span") %>%
        rvest::html_attr(name = "class") %>%
        magrittr::equals("txt_barre") %>%
        purrr::map_lgl(isTRUE)
      
      raw_subextract %<>%
        magrittr::extract(!is_cancelled)
      
      if (length(raw_subextract)) {
        
        referendum_dates %<>% tibble::add_row(ballot_date = !!ballot_date,
                                              level = !!level[i],
                                              municipality =
                                                dplyr::if_else(condition = level == "municipal",
                                                               true = vote_locations[i],
                                                               false = NA_character_),
                                              subject =
                                                raw_subextract %>%
                                                rvest::html_text() %>%
                                                stringr::str_squish())
      }
    }
  }
  
  referendum_dates
}
```

###### Scrape a referendum date after 2018-06-10

This function scrapes the ballot-date-specific subpages of the new format which were introduced with the vote on the `2018-09-23`.

**Remarks:**

- Exclusion of cancelled proposals (none as of 2018-11-25) hasn't been implemented in the function below because
    1. it's unclear if they will still be listed on the new page layout at all.
    2. if they will be listed, we don't know yet how they will be formatted.

```{r}
scrape_geneva_referendum_date_after_mid_2018 <- function(ballot_date,
                                                         url) {
  raw_extract <- xml2::read_html(x = url,
                                 # subpage format has changed from 2018-09-23 onwards
                                 encoding = "UTF-8")
  
  # get all "objet_*" selectors
  objet_selectors <-
    raw_extract %>%
    rvest::html_nodes(css = ".container") %>%
    rvest::html_nodes(css = "*") %>%
    rvest::html_attr("id") %>%
    unique() %>%
    magrittr::extract(stringr::str_detect(string = .,
                                          pattern = "^objet_")
                      & !is.na(.)) %>%
    paste0("#", .)
  
  vote_locations <-
    raw_extract %>%
    rvest::html_nodes(css = ".container") %>%
    rvest::html_nodes(css = "h2") %>%
    rvest::html_text() %>%
    magrittr::extract(!stringr::str_detect(string = .,
                                           pattern = "(?i)(documentation|(f\u00e9d\u00e9ra|cantona)(l|ux))")) %>%
    stringr::str_extract(pattern = "(?<=\\s)\\S+$") %>%
    stringr::str_to_title() %>%
    # undo uppercasing of "middle words" (like the "La" in "Aire-La-Ville")
    gsub(pattern = "(-.+?-)",
         replacement = "\\L\\1",
         perl = TRUE)
  
  if (length(vote_locations) == 0L) vote_locations <- NA_character_
  
  subjects <-
    raw_extract %>%
    rvest::html_nodes(css = paste0(objet_selectors, collapse = ","))
  
  subjects <-
    subjects %>%
    rvest::html_nodes(css = "strong") %>%
    rvest::html_text() %>%
    stringr::str_squish() %>%
    paste(subjects %>%
            rvest::html_nodes(css = "small") %>%
            rvest::html_text() %>%
            stringr::str_squish(),
          sep = " \u2013 ")
  
  referendum_dates <- tibble::tibble(ballot_date = ballot_date,
                                     level =
                                       objet_selectors %>%
                                       stringr::str_extract(pattern = "(?<=^#objet_).+?(?=_)") %>%
                                       stringr::str_replace(pattern = "FED", replacement = "federal") %>%
                                       stringr::str_replace(pattern = "CAN", replacement = "cantonal") %>%
                                       stringr::str_replace(pattern = "COM", replacement = "municipal"),
                                     municipality = vote_locations,
                                     subject = subjects)
  
  referendum_dates
}
```

##### Get election dates from Geneva's official website

**Remarks:**

- This function scrapes the Genevan election dates and subjects from <https://www.ge.ch/elections/> and returns them as a dataframe.

- The regex-based string detection we have to rely on to identify the political `level` is pretty fuzzy. It might need an update from time to time.

- The relevant website <https://www.ge.ch/elections/> is not of a well-structured enough form to retrieve all the data of interest programmatically. Therefore the function below returns a `subject_summary` of the ballot date (providing the information what institutions were elected in varying levels of detail) instead of the individual `subject`s (i.e. elected institutions, one per row), and a `link` pointing to the relevant subpage where more info about the election date can be found.

```{r}
get_geneva_election_dates <- function() {
  
  raw_extract <-
    xml2::read_html(x = "https://www.ge.ch/elections/",
                    encoding = "UTF-8") %>%
    rvest::html_nodes(css = ".liste-lien") %>%
    rvest::html_nodes(css = "li") %>%
    rvest::html_nodes(css = "a") %>%
    # remove erroneous 2nd link @ 1993-10-17 (only visible in source)
    magrittr::extract(-72L)
  
  election_dates <-
    tibble::tibble(ballot_date =
                     raw_extract %>%
                     rvest::html_attr(name = "href") %>%
                     stringr::str_extract(pattern = "\\d{8}") %>%
                     lubridate::ymd(),
                   subject_summary =
                     raw_extract %>%
                     rvest::html_text() %>%
                     stringr::str_squish(),
                   is_federal =
                     stringr::str_detect(string = subject_summary,
                                         pattern = "(?i)(Conseil\\s+(des\\s+.tats|National)|f(\u00e9|e)d(\u00e9|e)rale)"),
                   is_cantonal =
                     !is_federal &
                     stringr::str_detect(string = subject_summary,
                                         pattern = paste0("(?i)(",
                                                          "Grand\\s+Conseil|Conseil(ler)?\\s+d.?.tat|Cour\\s+(des?\\s+comptes|d.?appel)",
                                                          "|^Elections\\s+judiciaires$",
                                                          "|Pouvoir\\s+Judiciaire",
                                                          "|Assembl(\u00e9|e)e\\s+constituante",
                                                          ")")),
                   is_municipal =
                     (!is_federal & !is_cantonal),
                   link =
                     raw_extract %>%
                     rvest::html_attr(name = "href") %>%
                     paste0(ifelse(test = stringr::str_detect(string = .,
                                                              pattern = "^https?://"),
                                   yes = "",
                                   no = "https://www.ge.ch/elections/"), .)) %>%
    dplyr::arrange(ballot_date)
  
  if (election_dates %>%
      dplyr::select(is_federal, is_cantonal, is_municipal) %>%
      rowSums() %>%
      magrittr::is_greater_than(1L) %>%
      any() %>%
      magrittr::not())
  {
    election_dates %<>% dplyr::transmute(ballot_date,
                                         level = dplyr::case_when(is_federal ~ "federal",
                                                                  is_cantonal ~ "cantonal",
                                                                  is_municipal ~ "municipal"),
                                         subject_summary,
                                         link)
    
  } else {
    rlang::abort("Elections on multiple levels at the same date detected! Please update the code of `get_geneva_election_dates()` to support this properly.")
  }
  
  election_dates
}
```

###### Get municipal election dates from Geneva's official website

**BROKEN!** but should be fixable. 1st row of `election_dates` seems to cause the issue...

This function builds upon `get_geneva_election_dates()` and tries to determine the actual municipalities involved in the municipal election dates.

```{r}
get_geneva_municipal_election_dates <- function() {
  
  genevan_municipalities <- municipalities(canton = "Geneva")
  
  election_dates <-
    get_geneva_election_dates() %>%
    dplyr::filter(level == "municipal") %>%
    dplyr::select(-level) %>%
    dplyr::mutate(municipality = NA_character_) %>%
    # fix URLs
    dplyr::mutate(link = stringr::str_remove(string = link,
                                             pattern = "res_cn_home.asp$"))
  
  additional_rows <- election_dates[0L, ]
  
  # determine municipalities ...
  for (i in seq_len(nrow(election_dates))) {
    
    # initialize potentially to replace subject summary
    new_subject_summaries <- character(0L)
    
    # ...  where already mentioned in subject summary ...
    matched_municipality <- genevan_municipalities[stringr::str_detect(string = election_dates$subject_summary[i],
                                                                       pattern = paste0("\\b", genevan_municipalities, "\\b"))]
    
    # ... or otherwise by inspecting the relevant subpages
    if (length(matched_municipality) == 0L) {
      
      matched_municipalities <- character()
      
      raw_extract <- xml2::read_html(x = election_dates$link[i],
                                     encoding = "UTF-8")
      
      # handle "normal" subpage layout
      try_to_match <-
        raw_extract %>%
        rvest::html_nodes(css = ".liste-lien") %>%
        rvest::html_nodes(css = "li") %>%
        rvest::html_nodes(css = "a")
      
      # handle different subpage layout (e.g. 2007-06-03)
      if (length(try_to_match) == 0L) {
        
        try_to_match <-
          raw_extract %>%
          rvest::html_nodes(css = ".content") %>%
          rvest::html_nodes(css = "h2")
      }
      
      try_to_match %<>%
        rvest::html_text() %>%
        stringr::str_squish()
      
      if (length(try_to_match)) {
        
        for (j in seq_along(try_to_match)) {
          
          matched_municipalities %<>%
            c(genevan_municipalities[stringr::str_detect(string = try_to_match[j],
                                                         pattern = paste0("\\b", genevan_municipalities, "\\b"))])
        }
      }
      
      if (length(matched_municipalities) == 0L) {
        
        # handle yet another subpage layout (-> one level deeper)
        subpage_links <-
          raw_extract %>%
          rvest::html_nodes(css = ".liste-lien") %>%
          rvest::html_nodes(css = "li") %>%
          rvest::html_nodes(css = "a") %>%
          rvest::html_attr(name = "href") %>%
          purrr::map_chr(~ paste0(election_dates$link[i], .x))
        
        for (link in subpage_links) {
          
          raw_extract <- xml2::read_html(x = link,
                                         encoding = "UTF-8")
          
          new_subject_summary <-
            raw_extract %>%
            rvest::html_nodes(css = ".content") %>%
            rvest::html_nodes(css = "h2") %>%
            rvest::html_text() %>%
            stringr::str_squish()
          
          if (length(new_subject_summary) != 1L) {
            
            rlang::abort("Unexpected scraping result! Please update the code of `get_geneva_municipal_election_dates()`.")
            
          } else {
            
            new_subject_summaries %<>% c(new_subject_summary)
          }
          
          try_to_match <-
            raw_extract %>%
            rvest::html_nodes(css = ".liste-lien") %>%
            rvest::html_nodes(css = "li") %>%
            rvest::html_nodes(css = "a") %>%
            rvest::html_text() %>%
            stringr::str_squish()
          
          if (length(try_to_match)) {
            
            for (j in seq_along(try_to_match))
            {
              matched_municipalities %<>% c(genevan_municipalities[stringr::str_detect(string = try_to_match[j],
                                                                                       pattern = paste0("\\b", genevan_municipalities, "\\b"))])
            }
          }
        }
        
        # assign 1st matched municipalitiy to original row ...
        matched_municipality <- matched_municipalities[1L]
        
        # ... and set the rest aside to append later on
        additional_rows %<>% tibble::add_row(ballot_date = election_dates$ballot_date[i],
                                             subject_summary =
                                               sapply(X = new_subject_summaries,
                                                      FUN = rep,
                                                      times = length(matched_municipalities) / length(new_subject_summaries),
                                                      simplify = FALSE) %>%
                                               unlist() %>%
                                               magrittr::extract(-1L),
                                             link = election_dates$link[i],
                                             municipality = matched_municipalities[-1L])
        
      } else {
        
        # assign 1st matched municipality to original row ...
        matched_municipality <- matched_municipalities[1L]
        
        # ... and set the rest aside to append later on
        additional_rows %<>% tibble::add_row(ballot_date = election_dates$ballot_date[i],
                                             subject_summary = election_dates$subject_summary[i],
                                             link = election_dates$link[i],
                                             municipality = matched_municipalities[2L:length(matched_municipalities)])
      }
    } else if (length(matched_municipality) > 1L) {
      
      rlang::abort("Multiple municipalities detected in `subject_summary`! Please update the code of `get_geneva_municipal_election_dates()`.")
    }
    
    election_dates$municipality[i] <- matched_municipality
    if (length(new_subject_summaries)) election_dates$subject_summary[i] <- new_subject_summaries[1L]
  }
  
  # append remaining municipalities
  election_dates %<>% dplyr::bind_rows(additional_rows)
  
  # remove duplicates (Corsier was sometimes archived later and thus appears twice in such cases)
  duplicate_indices <- integer()
  
  for (i in stringr::str_which(string = election_dates$link,
                               pattern = "^https://www\\.ge\\.ch/elections/\\d+?/.+$")) {
    
    if (election_dates$link[-i] %>%
        stringr::str_detect(pattern = paste0(stringr::str_extract(string = election_dates$link[i],
                                                                  pattern = "^https://www\\.ge\\.ch/elections/\\d+"),
                                             "/?$")) %>%
        any()) {
      
      duplicate_indices %<>% c(i)
    }
  }
  
  election_dates %>%
    dplyr::filter(!(dplyr::row_number(link) %in% duplicate_indices)) %>%
    # sort columns
    dplyr::transmute(ballot_date,
                     municipality,
                     subject = subject_summary) %>%
    # sort rows
    dplyr::arrange(ballot_date, municipality)
}
```

#### Zurich

There are two major issues concerning the ballot dates from the Canton of Zurich:

1. Only cantonal referendums can be easily scraped. For [cantonal elections](https://wahlen-abstimmungen.zh.ch/internet/justiz_inneres/wahlen-abstimmungen/de/wahlen/wahlarchiv.html) there doesn't seem to exist anything well structured so far.

2. Municipal referendums aren't collected centrally anywhere (the canton just [points to the municipal/city administrations](https://wahlen-abstimmungen.zh.ch/internet/justiz_inneres/wahlen-abstimmungen/de/fragen-antworten.html)), so they can't be scraped from a single site. Instead we have to scrape all the individual sites of the different municipalities (13 currently) to get this data. In some cases (4 currently) there's no kind of vote archive available at all we could scrape and in other cases (2 currently) the website is not of a well-structured enough form to retrieve all the data of interest programmatically (we just try to return as much as possible).

##### Get federal and cantonal referendum dates from Zurich's official website

**Remarks:**

- This function scrapes the referendum dates and subjects from <https://www.web.statistik.zh.ch/cms_abstimmungsarchiv/index.php> and returns them as a tibble.

- Set the parameter `exclude_counterproposals` to `TRUE` in order to exclude indirect counterproposals and tie-breaker questions.

- The data can be retrieved as a JSON object from this URL: <http://www.web.statistik.zh.ch/cms_abstimmungsarchiv/includes/ajax_get_vorlagen.php>.
    - By default all data is returned. URL parameters can be passed to narrow the results. Currently known parameters:
        - `vorlageid` accepts referendum IDs of the form `vorlageid=2474`
        - `tag` accepts dates of the form `tag=10.06.2018`
    - If you set the parameter `search=true`, the API accepts the following parameters:
        - `thema` of the values
            - `1` for topic "Staatsordnung"
            - `2` for topic "Aussenpolitik"
            - `3` for topic "Sicherheitspolitik"
            - `4` for topic "Wirtschaft"
            - `5` for topic "Landwirtschaft"
            - `6` for topic "öffentliche Finanzen"
            - `7` for topic "Energie"
            - `8` for topic "Verkehr und Infrastruktur"
            - `9` for topic "Umwelt und Lebensraum"
            - `10` for topic "Soziale Fragen – Sozialpolitik"
            - `11` for topic "Bildung und Forschung"
            - `12` for topic "Kultur – Religion – Medien"
        - `abstimmungstyp` of the value `1` (federal only) or `2` (cantonal only)
        - `datum` accepts dates of the form `datum=10.06.2018`
        - `von_jahr` accepts a lower limit year of the form `von_jahr=2000`
        - `bis_jahr`accepts an upper limit year of the form `bis_jahr=2010`
        - `titel` to search for words occuring in the title of the referendum; multiple words must be separated by `/`; example to search for the words `geld` and `spiel`: `titel=geld/spiel`
        - `and_search=on` to restrict the results of a `titel` search to those that match _all_ words at once.
        - `resultat` of the value `angenommen` (adopted proposals only) or `abgelehnt` (rejected proposals only)
      
```{r}
get_zurich_referendum_dates <- function(exclude_counterproposals = FALSE) {
  
  referendum_dates <-
    jsonlite::fromJSON(txt = "https://www.web.statistik.zh.ch/cms_abstimmungsarchiv/includes/ajax_get_vorlagen.php") %$%
    aaData %>%
    magrittr::set_colnames(paste0("V", seq_len(ncol(.)))) %>%
    tibble::as_tibble() %>%
    dplyr::transmute(id = as.integer(V1),
                     ballot_date = lubridate::dmy(V2),
                     level =
                       V3 %>%
                       stringr::str_extract(pattern = "(?<=title=\").+?(?=\")") %>%
                       stringr::str_replace_all(c("Eidgen\u00f6ssische Abstimmung" = "federal",
                                                  "Kantonale Abstimmung" = "cantonal")),
                     subject =
                       .$V4 %>%
                       paste0(collapse = "\n") %>%
                       xml2::read_html() %>%
                       rvest::html_text() %>%
                       stringr::str_split(pattern = "\n") %>%
                       unlist() %>%
                       stringr::str_squish(),
                     type = V5,
                     turnout =
                       V6 %>%
                       stringr::str_extract(pattern = "\\d+(\\.\\d+)?") %>%
                       as.numeric() %>%
                       magrittr::divide_by(100L),
                     yes_vote_share =
                       V7 %>%
                       stringr::str_extract(pattern = "\\d+(\\.\\d+)?") %>%
                       as.numeric() %>%
                       magrittr::divide_by(100L)) %>%
    dplyr::arrange(ballot_date, level, type)
  
  # exclude indirect counterproposals and tie-breaker questions
  if (exclude_counterproposals) {
    
    referendum_dates %<>% dplyr::filter(!stringr::str_detect(string = type,
                                                             pattern = "(^|:\\s+)(Gegenvorschlag|Stichfrage)"))
  }
  
  referendum_dates
}
```

##### Get municipal ballot dates from the different official Zurich municipal websites

**Remarks:**

- Set the parameter `exclude_counterproposals` to `TRUE` in order to exclude indirect counterproposals and tie-breaker questions. Note that the exclusion is only really implemented yet for the municipality of Zurich because the other municipalities don't show any indirect counterproposals and tie-breaker questions up until now (effective July 2018). 

```{r}
get_zurich_municipal_ballot_dates <- function(municipalities = NULL,
                                              exclude_counterproposals = FALSE) {
  
  valid_municipalities <- c("Bertschikon",
                            "Boppelsen",
                            "Bubikon",
                            "B\u00fclach",
                            "Fehraltorf",
                            "Kleinandelfingen",
                            "M\u00e4nnedorf",
                            "Maur",
                            "Mettmenstetten",
                            "Schlieren",
                            "Thalwil",
                            "Wiesendangen",
                            "Winterthur",
                            "Z\u00fcrich")
  
  if (is.null(municipalities)) municipalities <- valid_municipalities
  
  # check argument
  test_subset <- checkmate::check_subset(x = municipalities,
                                         choices = valid_municipalities)
  
  if (!isTRUE(test_subset)) {
    
    rlang::abort("Invalid argument provided: `municipalities`\n", test_subset)
  }
  
  unimplemented_municipalities <- c("Bertschikon",
                                    "Bubikon",
                                    "Fehraltorf",
                                    "Kleinandelfingen",
                                    "Wiesendangen",
                                    "Winterthur")
  
  partially_implemented_municipalities <- c("B\u00fclach",
                                            "Maur")
  
  data <- tibble::tibble(ballot_date = lubridate::as_date(integer()),
                         municipality = character(),
                         is_election = logical(),
                         subject = character(),
                         url = character())
  
  for (municipality in municipalities) {
    
    if (municipality %in% unimplemented_municipalities) {
      
      rlang::warn(glue::glue("Scraping ballot dates from the municipality {municipality} hasn't been implemented yet (or isn't even possible to implement). ",
                             "Therefore its municipal ballot dates won't be included."))
      
    } else if (municipality %in% partially_implemented_municipalities) {
      
      rlang::warn(glue::glue("Scraping ballot dates from the municipality {municipality} is only partially implemented so far and the structure of the ",
                             "returned data differs from the other municipalities. Therefore its municipal ballot dates won't be included."))
    } else {
      
      # print a warning about missing election dates from Zurich
      if (municipality == "Z\u00fcrich") {
        
        rlang::warn(glue::glue("For the municipality {municipality} only referendum dates can be scraped. The municipal elections dates have to be gathered ",
                               "by hand."))
      }
      
      data_current <- switch(EXPR = municipality,
                             "Boppelsen" = get_zurich_municipal_dates_boppelsen(),
                             "M\u00e4nnedorf" = get_zurich_municipal_dates_maennedorf(),
                             "Mettmenstetten" = get_zurich_municipal_dates_mettmenstetten(),
                             "Schlieren" = get_zurich_municipal_dates_schlieren(),
                             "Thalwil" = get_zurich_municipal_dates_thalwil(),
                             "Winterthur" = get_zurich_municipal_dates_winterthur(),
                             "Z\u00fcrich" = get_zurich_municipal_dates_zuerich(exclude_counterproposals = exclude_counterproposals))
      
      data %<>% dplyr::full_join(y = data_current,
                                 by = colnames(data_current))
    }
  }
  
  data %>% dplyr::arrange(ballot_date, municipality, is_election)
}
```

###### Helper code

**Regex:**

We define the regular expression to detect elections here so it can be easily reused:

```{r}
election_regex <- "(?i)(^Pfarrer\\s|\\b(Erneuerungs?|Ersatz|Pfarr)?wahl(en|gang|g\u00e4nge)?\\b)"
```

---

**Generic functions:**

These are generic functions to scrape the ballot dates from municipal websites relying on widely applied (PHP) sites (obviously developed by the same
interactive agency [i-web](https://www.i-web.ch/)).

Old PHP site:

- The variable `is_election` is determined by some fuzzy regex-based string detection. Be sure to check from time to time if the defined regular expression
  still captures _all_ of the elections.

- The site requires a minimum date passed as a URL parameter (`date_f`), which means the function won't return any dates before then. We set it to the date
  `2000-01-01` by default.

```{r}
get_zurich_municipal_dates_generic_iweb_1 <- function(municipality,
                                                      base_url,
                                                      start_date = "2000-01-01",
                                                      municipal_types = c("bezirk", "kirchlich", "kommunal", "kreis", "verband")) {
  start_date %<>% lubridate::as_date()
  
  base_url %<>% paste0("?date_f=",
                       start_date %>% lubridate::day() %>% stringr::str_pad(width = 2L, side = "left", pad = "0"), ".",
                       start_date %>% lubridate::month() %>% stringr::str_pad(width = 2L, side = "left", pad = "0"), ".",
                       lubridate::year(start_date))
  
  data <- tibble::tibble(ballot_date = lubridate::as_date(integer()),
                         municipality = character(),
                         is_election = logical(),
                         subject = character())
  
  for (municipal_type in municipal_types) {
    
    raw_extract <-
      xml2::read_html(x = paste0(base_url, "&niveau=", municipal_type),
                      encoding = "windows-1252") %>%
      rvest::html_nodes(css = "table") %>%
      dplyr::last() %>%
      rvest::html_table() %>%
      tibble::as_tibble()
    
    if (all(c("Termin", "Titel der Vorlage") %in% colnames(raw_extract))) {
      
      data <-
        raw_extract %>%
        dplyr::transmute(ballot_date = lubridate::dmy(Termin),
                         municipality = !!municipality,
                         is_election = stringr::str_detect(string = `Titel der Vorlage`,
                                                           pattern = election_regex),
                         subject = `Titel der Vorlage`) %>%
        dplyr::bind_rows(data)
    }
  }
  
  if (nrow(data) == 0L) {
    
    rlang::abort(paste0("No <table> node of the expected structure was returned. You might have to update the `get_zurich_municipal_dates_generic_iweb_1()` ",
                        "function."))
  }
  
  data %>% dplyr::arrange(ballot_date, municipality, is_election)
}
```

New site:

```{r}
get_zurich_municipal_dates_generic_iweb_2 <- function(municipality,
                                                      base_url) {
  
  data <-
    xml2::read_html(glue::glue("{base_url}/abstimmungen/vorlagen")) %>%
    rvest::html_nodes("table") %>%
    rvest::html_nodes("tbody") %>%
    # 1st table contains referendums, 2nd table contains elections
    purrr::map(~ {
      
      rvest::html_nodes(x = .x,
                        css = "tr") %>%
        purrr::map_dfr(~ {
          
          # 1st cell contains date, 2nd cell contains href and subject
          cells <- rvest::html_nodes(x = .x,
                                     css = "td")
          tibble::tibble(ballot_date =
                           cells[[1]] %>%
                           rvest::html_attr("data-order") %>%
                           lubridate::as_date(),
                         subject =
                           cells[[2]] %>%
                           rvest::html_node(css = "a") %>%
                           rvest::html_text(),
                         url =
                           cells[[2]] %>%
                           rvest::html_node(css = "a") %>%
                           rvest::html_attr("href") %>%
                           paste0(base_url, .))
        })
    })
  
  # merge referendum and election tables
  dplyr::bind_rows(data[[1]] %>% dplyr::mutate(is_election = FALSE),
                   data[[2]] %>% dplyr::mutate(is_election = TRUE)) %>%
    dplyr::mutate(municipality = !!municipality) %>%
    dplyr::select(ballot_date, municipality, is_election, subject, url) %>%
    dplyr::arrange(ballot_date, is_election)
}
```

###### Boppelsen

**Remarks**:

- Due to the bad/ambiguous structure of the website it's rather tricky to identify elections on the level of individual votes and the regex-based string detection we have to rely on is pretty fuzzy. Be sure to check from time to time if the defined regular expression still captures _all_ of the elections.

- There's currently no secure HTTPS version of the site available.

```{r}
get_zurich_municipal_dates_boppelsen <- function() {
  
  raw_extract <-
    xml2::read_html(x = "http://www.boppelsen.ch/gemeinde/politik/wahlen/archiv/default.htm",
                    encoding = "windows-1252") %>%
    rvest::html_nodes(css = ".portletDocumentListWrapper")
  
  ballot_dates <- tibble::tibble(ballot_date = lubridate::as_date(integer()),
                                 municipality = character(),
                                 is_election = logical(),
                                 subject = character())
  
  summary_texts <-
    raw_extract %>%
    rvest::html_nodes(css = "h3") %>%
    rvest::html_text()
  
  dates <-
    summary_texts %>%
    stringr::str_extract(pattern = "\\d+\\.\\s+\\S+\\s+\\d{4}(\\s+)?$") %>%
    lubridate::dmy()
  
  is_election_date <- stringr::str_detect(string = summary_texts,
                                          pattern = "(?i)wahl")
  
  raw_extract %<>% rvest::html_nodes(css = "ul")
  
  for (i in seq_along(dates)) {
    
    subject_part <-
      raw_extract[[i]] %>%
      rvest::html_nodes(css = "li") %>%
      rvest::html_nodes(css = "a") %>%
      rvest::html_attr(name = "title") %>%
      # filter non-municipal subjects
      magrittr::extract(!stringr::str_detect(string = .,
                                             pattern = "(?i)((national|st(\u00e4|ae)nde|kantons|regierungs)rat|eidge?n\u00f6ssis?che|kantonale)"))
    
    if (length(subject_part)) {
      
      ballot_dates %<>% tibble::add_row(ballot_date = dates[i],
                                        municipality = "Boppelsen",
                                        is_election =
                                          is_election_date[i] &
                                          !stringr::str_detect(string = subject_part,
                                                               pattern = "(?i)(abstimmung|initiative|kredit|referendum|revision)"),
                                        subject = paste0(summary_texts[i], ": ", subject_part))
    }
  }
  
  ballot_dates %>% dplyr::arrange(ballot_date, municipality, is_election)
}
```

###### Bülach

**Remarks**:

- The relevant website <https://www.buelach.ch/themen/politik_verwaltung/wahlen_und_abstimmungen/wahlen_und_abstimmungen_resultate/> doesn't provide the
  information we need in a well-structured form. Therefore the function below returns a `subject_summary` of the ballot date (mostly providing the information
  if it was a referendum, election or both) instead of the individual `subject`s, and a `url` pointing to the relevant subpage where more info about the ballot
  date is found.

```{r}
get_zurich_municipal_dates_buelach <- function() {
  
  raw_extract <-
    xml2::read_html(x = "https://www.buelach.ch/themen/politik-verwaltung/wahlen-und-abstimmungen/abstimmungen-und-wahlen-resultate",
                    encoding = "UTF-8") %>%
    rvest::html_nodes(css = ".element") %>%
    rvest::html_nodes(css = ".list") %>%
    dplyr::first() %>%
    rvest::html_nodes(css = "ul") %>%
    rvest::html_nodes(css = "li")
  
  tibble::tibble(ballot_date =
                   raw_extract %>%
                   rvest::html_nodes(css = ".date") %>%
                   rvest::html_text() %>%
                   lubridate::dmy(),
                 municipality = "B\u00fclach",
                 subject_summary =
                   raw_extract %>%
                   rvest::html_nodes(css = ".title") %>%
                   rvest::html_text(),
                 is_election_date = stringr::str_detect(string = subject_summary,
                                                        pattern = "(?i)wahl"),
                 url =
                   raw_extract %>%
                   rvest::html_nodes("a") %>%
                   rvest::html_attr(name = "href") %>%
                   paste0("https://www.buelach.ch/", .)) %>%
    dplyr::transmute(ballot_date, municipality, is_election_date, subject_summary, url) %>%
    dplyr::arrange(ballot_date, municipality, is_election_date)
}
```

###### Männedorf

**Remarks**:

- The variable `is_election` is determined by some fuzzy regex-based string detection. Be sure to check from time to time if the defined regular expression still captures _all_ of the elections.

- The site requires a minimum date passed as a URL parameter (`date_f`). We set it to the date `2000-01-01`, which means this function won't return any dates before then.

- There's currently no secure HTTPS version of the site available.

```{r}
get_zurich_municipal_dates_maennedorf <- function() {
  
  get_zurich_municipal_dates_generic_iweb_1(municipality = "M\u00e4nnedorf",
                                            base_url = "http://www.maennedorf.ch/de/politik/abstimmungsresultate/archivsuche/welcome.php")
}
```

###### Maur

**Remarks**:

- The archive available on <https://www.maur.ch/politik-verwaltung/politik/wahlen-abstimmungen.html/52/newsarchive/true> doesn't provide the information we
  need in a well-structured form. Therefore the function below returns a `subject_summary` of the ballot date (often just announcing a certain ballot in the
  future) instead of the individual ballot `subject`s, and a `url` pointing to the relevant subpage where more information about the actual ballot is
  available.

- Development note: The web server seems to block the requesting IP address if it detects scraping attempts. In that case, the HTTP error 403 will be returned.

```{r}
get_zurich_municipal_dates_maur <- function() {
  
  response <- httr::GET(url = "https://www.maur.ch/politik-verwaltung/politik/wahlen-abstimmungen.html/52/newsarchive/true",
                        httr::user_agent(agent = "Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0"))
  
  cookies <-
    response$cookies %>%
    dplyr::select(name, value) %>%
    tibble::deframe()
  
  raw_extract <-
    httr::POST(url = "https://www.maur.ch/politik-verwaltung/politik/wahlen-abstimmungen.html/52/newsarchive/true",
           httr::user_agent(agent = "Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0"),
           # TODO: fix this; Cookie values below are just copy-pasted from a browser session
           httr::set_cookies(cookies),
           httr::content_type(type = "application/x-www-form-urlencoded"),
           body = list(newsSearchParams.query = "",
                       # `newsSearchParams.category = 8` stands for "Wahlen / Abstimmungen"
                       newsSearchParams.category = 8,
                       newsSearchParams.dateFrom = "",
                       newsSearchParams.dateTo = ""),
           encode = "form") %>%
    xml2::read_html(encoding = "UTF-8") %>%
    rvest::html_node(".news-lst-archive") %>%
    rvest::html_nodes("li")
  
  # NOTE: The structure of the returned list is crap! The <time> is just the publication time of the "news entry" and does NOT necessarily match the ballot
  #       date. It's also impossible to extract the actual ballot date from the `subject_summary` for certain entries (e.g. the "Ersatzwahl des Notars
  #       beziehungsweise der Notarin für den Rest der Amtsdauer 2018–2022"), so we don't even try...
  tibble::tibble(ballot_date =
                   raw_extract %>%
                   rvest::html_nodes("time") %>%
                   rvest::html_attr("datetime") %>%
                   stringr::str_extract("\\d{4}-\\d{2}-\\d{2}") %>%
                   lubridate::as_date(),
                 municipality = "Maur",
                 subject_summary =
                   raw_extract %>%
                   rvest::html_nodes("a") %>%
                   rvest::html_text(),
                 is_election = stringr::str_detect(string = subject_summary,
                                                   pattern = "(?i)wahl"),
                 url =
                   raw_extract %>%
                   rvest::html_nodes("a") %>%
                   rvest::html_attr("href")) %>%
    dplyr::select(ballot_date, municipality, is_election, subject_summary, url) %>%
    dplyr::arrange(ballot_date, is_election)
}
```

###### Mettmenstetten

**Remarks**:

- Unfortunately the archive hosted on <https://www.mettmenstetten.ch/abstimmungen/vorlagen> provides only ballot dates back to the beginning of the year 2017.
  Currently there doesn't seem to exist any way to retrieve earlier ballot dates from Mettmenstetten.

```{r}
get_zurich_municipal_dates_mettmenstetten <- function() {
  
  get_zurich_municipal_dates_generic_iweb_2(
    municipality = "Mettmenstetten",
    base_url = "https://www.mettmenstetten.ch"
  )
}
```

###### Schlieren

```{r}
get_zurich_municipal_dates_schlieren <- function() {
  
  get_zurich_municipal_dates_generic_iweb_2(municipality = "Schlieren",
                                            base_url = "https://www.schlieren.ch")
}
```

###### Thalwil

**Remarks**:

- There's currently no secure HTTPS version of the site available.

```{r}
get_zurich_municipal_dates_thalwil <- function() {
  
  get_zurich_municipal_dates_generic_iweb_1(municipality = "Thalwil",
                                            base_url = "http://www.thalwil.ch/de/polver/politik/abstimmungsresultate/politrechtevorlagen/welcome.php")
}
```

###### Winterthur

**BROKEN!**

**Remarks**:

- There's currently no secure HTTPS version of the site available (always redirects to unencrypted HTTP version).

```{r}
get_zurich_municipal_dates_winterthur <- function() {
  
  raw_extract <-
    xml2::read_html("https://wahlen.winterthur.ch/archiv/vote-action/archive/vote-controller/ElectionDay/vote-year/9999/") %>%
    rvest::html_nodes(css = ".electionday-list") %>%
    rvest::html_nodes(css = ".row")
  
  ballot_dates <- tibble::tibble(ballot_date = lubridate::as_date(integer()),
                                 municipality = character(),
                                 is_election = logical(),
                                 subject = character())
  
  for (i in seq_along(raw_extract)) {
    
    if (raw_extract[[i]] %>%
        rvest::html_nodes(css = ".col-8") %>%
        rvest::html_text() %>%
        stringr::str_squish() %>%
        magrittr::equals("Es sind noch keine Wahlen/Abstimmungen vorhanden") %>%
        magrittr::not()) {
      
      ballot_dates %<>% tibble::add_row(ballot_date =
                                          raw_extract[[i]] %>%
                                          rvest::html_nodes(css = ".col-4") %>%
                                          rvest::html_text() %>%
                                          stringr::str_extract(pattern = "\\d+\\.\\d+\\.\\d{4}") %>%
                                          lubridate::dmy(),
                                        municipality = "Winterthur",
                                        subject =
                                          raw_extract[[i]] %>%
                                          rvest::html_nodes(css = ".col-8") %>%
                                          rvest::html_nodes(css = "ul") %>%
                                          rvest::html_nodes(css = "li") %>%
                                          rvest::html_text() %>%
                                          stringr::str_squish())
    }
  }
  
  ballot_dates %>%
    dplyr::mutate(is_election = stringr::str_detect(string = subject,
                                                    pattern = election_regex)) %>%
    dplyr::arrange(ballot_date, municipality, is_election)
}
```

###### Zürich

**Remarks**:

- Unfortunately only referendum dates seem to be available as CSV. Election dates have to be fetched elsewhere.

- Set the parameter `exclude_counterproposals` to `TRUE` in order to exclude indirect counterproposals and tie-breaker questions.

```{r}
get_zurich_municipal_dates_zuerich <- function(exclude_counterproposals = FALSE) {
  
  referendum_dates <-
    readr::read_csv(file = paste0("https://data.stadt-zuerich.ch/dataset/politik_abstimmungen_seit_1933/resource/3b5a8ed9-0765-4d59-95a1-e87aa98350e3/",
                                  "download/abstimmungen_seit1933.csv"),
                    locale = readr::locale(encoding = "UTF-8",
                                           decimal_mark = "."),
                    col_types = "Dicciciciiidddcc") %>%
    dplyr::filter(Name_Politische_Ebene == "Stadt Z\u00fcrich") %>%
    dplyr::group_by(ballot_date = Abstimmungs_Datum,
                    municipality = "Z\u00fcrich",
                    is_election = FALSE,
                    subject = Abstimmungs_Text) %>%
    dplyr::summarise() %>%
    dplyr::arrange(ballot_date, municipality) %>%
    # manual corrections
    ## exclude duplicate entries
    dplyr::filter(
      ### @ 1996-06-09
      !((ballot_date == "1996-06-09"
         & subject == "A Wohnbauaktion (Rahmenkredit je 10 Mio. Franken) \nB Wohnbauaktion (Rahmenkredit je 20 Mio. Franken) \n Wohnbauaktion (Stichfrage)")
        ### @ 1981-01-25
        | (ballot_date == "1981-01-25"
           & subject == "Gegenvorschlag des Stadtrates zur Volksinitiative \u00fcber die Errichtung eines Gesundheitszentrums im Kreis 9"))
    )
  
  if (exclude_counterproposals) {
    
    referendum_dates %<>% dplyr::filter(!stringr::str_detect(string = subject,
                                                             pattern = "(?i)(^[bc][\\s\\.:)]|stichfrage)"))
  }
  
  referendum_dates
}
```

# Retroactively merge municipalities that have merged

```{r}
#' Retroactively merge municipalities that have merged
#'
#' This function builds upon [swissmuni::mutations()] to find municipalities in `data` that have merged into another municipality and synthetically applies
#' this merger "back in time" as best as possible. This allows subsequent data analysis to better track/compare the development of e-voting usage over time.
#'
#' @param data The data in which to perform the retroactive municipality mergers.
#'
#' @return `pkgsnip::return_label("data")`
#' @export
merge_municipalities <- function(data) {
  
  # process each *canton* individually and merge result
  data %>%
    dplyr::group_by(canton) %>%
    dplyr::group_split() %>%
    purrr::map_dfr(merge_municipalities_by_canton)
}
```

## Process by canton

```{r}
merge_municipalities_by_canton <- function(data_canton) {
  
  start_date <- min(data_canton$date,
                    na.rm = TRUE)
  
  end_date <- max(data_canton$date,
                  na.rm = TRUE)
  
  mutations <-
    swissmuni::mutations(start_date = start_date,
                         end_date = end_date,
                         cache_lifespan = "1 week") %>%
    # ensure data is ordered chronologically
    dplyr::arrange(MutationDate)
  
  # extract relevant "daughter" municipality codes
  mutations_daughters <-
    mutations %>%
    dplyr::filter(InitialCode %in% setdiff(data_canton$municipality_code, NA)) %>%
    dplyr::filter(TerminalCode %in% setdiff(data_canton$municipality_code, NA))
  
  # terminate early if no relevant "daughter" municipality codes found
  if (nrow(mutations_daughters)) {
    
    # extract relevant data (includes more rows when not all merged municipalities are present in our data)
    mutations_relevant <- mutations %>% dplyr::filter(MutationNumber %in% mutations_daughters$MutationNumber)
    
    # process each *date* individually and merge result
    data_canton %>%
      dplyr::group_by(date) %>%
      dplyr::group_split() %>%
      purrr::map_dfr(merge_municipalities_by_canton_date,
                     mutations_relevant = mutations_relevant)
    
  } else {
    data_canton
  }
}
```

## Process a canton subset by date

```{r}
merge_municipalities_by_canton_date <- function(data_canton_date,
                                                mutations_relevant) {
  
  # process each **municipality merger** (=MutationNumber) individually
  mutation_nrs <-
    mutations_relevant %>%
    dplyr::filter(InitialCode %in% intersect(mutations_relevant$InitialCode,
                                             data_canton_date$municipality_code)) %$%
    MutationNumber %>%
    unique()
  
  for (mutation_nr in mutation_nrs) {
    
    mutations_daughter <- mutations_relevant %>% dplyr::filter(MutationNumber == mutation_nr)
    ix_daughter <- which(data_canton_date$municipality_code %in% mutations_daughter$InitialCode)
    
    if (length(ix_daughter)) {
      
      # process each **group** individually
      merged_rows <-
        data_canton_date[ix_daughter, ] %>%
        dplyr::group_by(group) %>%
        dplyr::group_split() %>%
        purrr::map_dfr(merge_municipalities_helper,
                       municipality_code_new = unique(mutations_daughter$TerminalCode),
                       municipality_new = unique(mutations_daughter$TerminalName),
                       target_colnames = colnames(data_canton_date))
      
      data_canton_date %<>%
        dplyr::filter(!(dplyr::row_number() %in% ix_daughter)) %>%
        dplyr::bind_rows(merged_rows)
    }
  }
  
  data_canton_date
}
```

## Merge municipalitites (helper)

```{r}
merge_municipalities_helper <- function(rows,
                                        municipality_code_new,
                                        municipality_new,
                                        target_colnames) {
  
  rows %>%
    dplyr::summarise(comments = paste0("Retroactively (i.e. synthetically) merged from the municipalities ", pal::prose_ls(municipality), "; ",
                                       paste0(unique(comments),
                                              collapse = "; ")),
                     municipality_code = checkmate::assert_int(municipality_code_new),
                     municipality_code_alt = NA_integer_,
                     municipality = checkmate::assert_string(municipality_new),
                     
                     # cols which _should_ be identical
                     dplyr::across(c(country,
                                     canton,
                                     district,
                                     starts_with("system"),
                                     date,
                                     is_preregistration_required,
                                     ends_with("_overlapping_aggregate"),
                                     nr_of_federal_referendums,
                                     nr_of_cantonal_referendums),
                                   unique),
                     
                     # cols which have to be combined logically
                     ## binary
                     dplyr::across(c(is_entire_group_in_all_votes,
                                     is_cross_vote_aggregated,
                                     is_wassenaar_corrected,
                                     is_matched_group),
                                   all),
                     ## 3-code
                     dplyr::across(c(type,
                                     federal_elected_power,
                                     matches("^(federal|cantonal|municipal|combined)_election_procedure$")),
                                   determine_3_code_combo),
                     ## group (6-code)
                     group = combine_group(group),
                     ## 7-code
                     dplyr::across(c(matches("^(referendum|election|combined)_level$"),
                                     matches("^(cantonal|municipal|combined)_elected_power$")),
                                   determine_7_code_combo),
                     
                     # cols which have to be summed up
                     dplyr::across(c(e_voting_electorate,
                                     total_electorate,
                                     vote_count_e_voting_electorate,
                                     ballot_votes_e_voting_electorate,
                                     postal_votes_e_voting_electorate,
                                     vote_count_total,
                                     ballot_votes_total,
                                     postal_votes_total,
                                     e_votes),
                                   ~ dplyr::if_else(all(is.na(.x)),
                                                    NA_integer_,
                                                    sum(.x,
                                                        na.rm = TRUE))),
                     dplyr::across(c(matched_group_notes,
                                     source),
                                   ~ paste0(unique(.x),
                                            collapse = "; ")),
                     
                     # other cols
                     nr_of_municipal_referendums = max(nr_of_cantonal_referendums,
                                                       na.rm = TRUE)) %>%
    # cols which have to be recalculated
    dplyr::mutate(total_nr_of_referendums = sum(nr_of_federal_referendums,
                                                nr_of_cantonal_referendums,
                                                nr_of_municipal_referendums,
                                                na.rm = TRUE),
                  group_name = get_group_name(group),
                  type_name = get_type_name(type),
                  referendum_level_name = get_level_name(referendum_level),
                  election_level_name = get_level_name(election_level),
                  combined_level_name = get_level_name(combined_level),
                  federal_elected_power_name = get_federal_elected_power_name(federal_elected_power),
                  cantonal_elected_power_name = get_elected_power_name(cantonal_elected_power),
                  municipal_elected_power_name = get_elected_power_name(municipal_elected_power),
                  combined_elected_power_name = get_elected_power_name(combined_elected_power),
                  federal_election_procedure_name = get_election_procedure_name(federal_election_procedure),
                  cantonal_election_procedure_name = get_election_procedure_name(cantonal_election_procedure),
                  municipal_election_procedure_name = get_election_procedure_name(municipal_election_procedure),
                  combined_election_procedure_name = get_election_procedure_name(combined_election_procedure),
                  
                  turnout = vote_count_e_voting_electorate / e_voting_electorate,
                  ballot_votes_share = ballot_votes_e_voting_electorate / vote_count_e_voting_electorate,
                  postal_votes_share = postal_votes_e_voting_electorate / vote_count_e_voting_electorate,
                  e_votes_share = e_votes / vote_count_e_voting_electorate,
                  e_votes_share_total_electorate = e_votes / total_electorate,
                  e_votes_share_e_voting_electorate = e_votes / e_voting_electorate) %>%
    # fix col order
    dplyr::select(all_of(target_colnames)) %>%
    # fix name of GE municipality "La Grande Beroche" (hyphen was officially dropped)
    dplyr::mutate(municipality = dplyr::if_else(municipality == "La Grande-B\u00e9roche",
                                                "La Grande B\u00e9roche",
                                                municipality))
}
```
